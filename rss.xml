<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛天的小窝</title>
  
  
  <link href="https://luotian.cyou/rss.xml" rel="self"/>
  
  <link href="https://luotian.cyou/"/>
  <updated>2025-10-31T18:47:19.915Z</updated>
  <id>https://luotian.cyou/</id>
  
  <author>
    <name>Luo Tian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>西电雨课堂 - 学术交流英语答案</title>
    <link href="https://luotian.cyou/post/Aca-Commu-Eng.html"/>
    <id>https://luotian.cyou/post/Aca-Commu-Eng.html</id>
    <published>2025-10-31T17:54:29.000Z</published>
    <updated>2025-10-31T18:47:19.915Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font size="4" color="00b9ff">前言：章节答案由我自己整理，期末考试暂未更新</font></strong></p><h2 id="center-第一章-center"><center>第一章</center></h2><ol><li>与大型专业会议相比,（）的规模较小，议题较窄，但讨论程度更为深入。<br>C、专题讨论会</li><li>正式英文信函的格式中简单直白，版式美观，易于掌握的格式是<br>A、齐头式</li><li>下面对信头描述错误的句子是<br>B、信头的写法一般是由大到小，分行列出。</li><li>下列关于金字塔原理的表述不正确的是哪一项？<br>C、“金字塔” 原理要与 “多事多议” 原则配合。</li><li>顾问委员会通常由有相当学术水平和工作经验的热心专家组成，学术会议成功与否与该委员会关系甚大。<br>×</li><li>国际学术会议通过全体会议、分组会议、展览会、参观考察、问答等正式的活动形式使得参会者们得以有效进行学术交流。<br>×</li><li>国际学术会议通知或邀请函是国际学术会议发出的第一份正式通知，目的是告知主题会议的举办，欢迎参会和投稿。<br>×</li><li>英国人习惯按月、日、年的顺序写，月和年之间必须使用逗号。<br>×</li><li>在较为严肃的学术邮件中，标点符号和字符表情可以随意使用，也可以用空格代替标点。<br>×</li><li>如果因休假或其他特殊情况无法回复邮件，可设置自动回复。<br>√</li></ol><h2 id="center-第二章-center"><center>第二章</center></h2><ol><li>以下哪一项内容不会出现在投稿信中？<br>D、稿件识别码</li><li>以下哪一项内容不是编写审稿意见回复信应遵循的原则？<br>C、若审稿人的意见有误，仍应按照审稿人的意见进行论文修改</li><li>I will send my paper entitled “Hepatitis C Virus Infection in Long-Term Transfusion Patients” to the Paper Committee before the required date. 该句最有可能出现在以下哪类信件中？<br>B、接受邀请信</li><li>国际学术会议的邀请函通常会在会议开始前多长时间发出？<br>C、3 个月</li><li>以下哪一项不符合参加国际学术会议的会场礼仪？<br>C、在自由发言环节，争抢发言，大声争论，手拿话筒滔滔不绝，随意打断他人发言。</li><li>国际学术会议的用餐形式主要有哪几种？<br>D、宴会、酒会和自助餐</li><li>向国外学术期刊或国际学术会议投稿时，若已将文章作为附件发送，则无需在邮件正文部分重复文章主要内容。<br>×</li><li>给学术会议写邮件进行咨询时，应语言简洁，直接提问即可，无需提及会议名称等信息。<br>×</li><li>在参加学术会议的自助餐时，可以主动寻找恰当的时机，在不打扰对方进餐的前提下积极地与其他学者进行交际活动。<br>√</li><li>使用名片是现代人交际的重要手段。递交名片时要用双手或左手，名片的背面朝向对方，同时注视对方，微笑致意。<br>×</li></ol><h2 id="center-第三章-center"><center>第三章</center></h2><ol><li>应该在（）下载和使用论文模板。<br>A、撰写论文前</li><li>以下不属于标题写作要求的是（）<br>C、专业</li><li>下列不属于背景语步交际功能的是（）<br>A、提出研究问题</li><li>“Nonalcoholic Fatty Liver Disease and Cardiovascular Risk: A Scientific Statement from the American Heart Association” ATVB, 2022 (42). 引号中的论文标题所属的类型是（）<br>B、详细主题型</li><li>“In this paper, the focus of the research is towards a prediction of whether an individual household is in a poverty situation through the analysis of their gas smart meter data.” 摘要中的这个句子实现了多少种交际功能？<br>C、3 种</li><li>Overleaf 等在线 Latex 编辑器比较适合用来团队撰写论文。<br>√</li><li>将最重要的信息放置在论文标题的首尾位置能显著提高标题的吸引力，增加论文被检索和阅读的机会。<br>√</li><li>为了增加标题吸引力，研究论文多采用修辞型标题。<br>×</li><li>提交的论文稿件如果没有遵循模板格式，会被直接拒稿。<br>√</li><li>摘要的语步结构是否完整会直接影响论文被录取的几率。<br>√</li></ol><h2 id="center-第四章-center"><center>第四章</center></h2><ol><li>The results of the study ___ that the number of times learners encounter an unknown word in context affects how likely they will learn that word successfully.<br>D、suggest</li><li>He now devotes himself to full-time research ___ costumes and their history.<br>C、on</li><li>We present ___ to illustrate the performance of our model.<br>A、a numerical method</li><li>下列哪项不属于相关研究的功能？<br>B、介绍研究主题，激发读者的阅读兴趣</li><li>___ they report promising tracking rates, they test the proposed approach with only four vehicles and its feasibility in real-time tracking is questionable.<br>A、Although</li><li>引言一般不包含研究假设、研究问题和研究方法的介绍。<br>×</li><li>研究问题或假设大多在文献综述结束后提出，在引言中出现时不一定明确使用 hypothesis、research questions 等。<br>√</li><li>相关研究三个语步一定要按照顺序出现，依次为：聚焦研究领域，总结前期研究，填补研究空缺。<br>×</li><li>相关研究部分在论文写作中相对较为容易，只需将前期研究成果按照时间顺序呈现给读者。<br>×</li><li>In the work proposed by Reilly et al. [29], a joint probabilistic relation graph with vertex and pairwise edge matching is presented to detect and track vehicles in aerial video sequences. 这句话介绍某领域的以往研究，时态不对，应改为一般过去时。<br>×</li></ol><h2 id="center-第五章-center"><center>第五章</center></h2><ol><li>学术论文方法部分常见的英文标题包括（）<br>D、All the above</li><li>以下哪一语阶属于方法部分的 “介绍背景信息” 这一语步？<br>B、介绍研究目的、提出研究问题或假设</li><li>以下哪句话不包含关于研究目的的描述？<br>C、Participants were given a brief tutorial and were asked to try the same problem.</li><li>学术论文结果与讨论部分常见的英文标题最有可能不包括（）<br>D、Experimental Setup</li><li>以下哪一句式不属于报告研究结果？<br>A、The study tested our central hypothesis that A will improve B.</li><li>方法部分通常按照研究者的研究思路来描述研究过程，证明研究步骤及方法的合理性以保证研究结果的可靠性，但无需保证研究的可重复性。<br>×</li><li>We compared latent representation obtained by a single VAE and the expected latent representation from our approach in Equation 4 and subsequently trained a support vector machine (SVM) with it. 这句话是在介绍分析方法。<br>×</li><li>结果部分主要说明研究结果是什么，而讨论部分则说明研究结果有何意义。<br>√</li><li>在学术论文的结果与讨论部分，报告研究结果和对研究结果进行解释或评价均属于第二语步 —— 说明研究结果。<br>√</li><li>Error discrepancy in the assisted condition was significantly lower than in the non-assisted condition. 这句话在对研究结果的数据进行比较，可以划入结果部分，也可以划入讨论部分。<br>√</li></ol><h2 id="center-第六章-center"><center>第六章</center></h2><ol><li>Before we conclude, it is important to ___ some limitations of the current study, which may ___ in future research.<br>D、acknowledge; be addressed</li><li>以下哪种格式是大多数生物医学期刊的引文样式？<br>A、温哥华格式</li><li>以下哪种格式主要用于人文社科领域，如英语语言文学、文学批评、比较文学和文化研究等？<br>D、MLA 格式</li><li>论文致谢应该使用以下哪种表述？<br>C、Acknowledgement</li><li>下列哪句话存在语法问题？<br>A、Houlsby et al. reduces the number of parameters to be updated by inserting adapter modules in every layer of Transformer model.</li><li>结论部分相对于其他部分而言通常要短得多，但是要自成一个部分，不与其他部分合并。<br>×</li><li>哈佛格式是一种作者 - 出版年引文系统，文内引用在括号中列出作者姓氏和出版年份。<br>√</li><li>MLA 格式是一种作者 - 出版年引文系统，文内引用时用括号标注作者姓氏和出版年份。<br>×</li><li>致谢不是必有项，一般出现在参考文献（References）之后。<br>×</li><li>图和表的标题通常出现在图和表的下方，图和表的英文单词 Figure 和 Table 可分别缩写为 Fig. 和 Tab.<br>×</li></ol><h2 id="center-第七章-center"><center>第七章</center></h2><ol><li>学术会议演讲的场景不包括（）<br>D、自助餐讨论</li><li>衡量一个演讲的有效性通常会从（）这几个方面展开。<br>A、结构、内容、语言、形式</li><li>需要提前了解的学术会议演讲相关信息不包括（）<br>B、学会与紧张情绪相处</li><li>以下哪一项描述与学术论文书面语言的特点不符？<br>C、术语必须要进行解释。</li><li>以下哪一项不是学术会议演讲稿的常见形式？<br>C、提示稿</li><li>学术会议通常是各个科研领域机构或研究者们组织的、由学术工作者们分享自己科研发现和获取最新科研进展信息的聚会。<br>√</li><li>学术会议演讲时不能照着讲稿读，需要把演讲稿内容全部背诵下来。<br>×</li><li>在学术会议的开场语部分，演讲者最好直接说出自己的名字，读一下 PPT 文稿第一页的演讲题目，然后直接进入到演讲的主体部分。<br>×</li><li>演讲的主体部分陈述研究内容，突出要点并进行必要的解释和说明，是整个演讲中最重要的部分。<br>√</li><li>提纲稿仅把演讲中的要点写出来，通常仅包含演讲的主要内容，如重要的信息、数字和关键的句子或短语等。<br>√</li></ol><h2 id="center-第八章-center"><center>第八章</center></h2><ol><li>以下哪一项不是使用 PowerPoint 等视觉辅助软件工具的目的？<br>A、使演讲者能够照着展示页面上的内容进行讲读，加深听众印象</li><li>以下关于 PowerPoint 设计的要点事项表述正确的是（）<br>D、幻灯片的设计应当避免相近的文字和背景颜色，黑、白和深灰是严肃学术演讲中常用的配色。</li><li>以下哪项内容不应该出现在目录页？<br>C、对听众表示感谢</li><li>主持人宣布会议开幕时，下列哪一种表达不适合大型国际学术会议？<br>B、Let’s get things started.</li><li>下列哪一项不属于闭幕词的特点？<br>A、宣告性</li><li>下列关于学术会议问答环节的说法不正确的是（）<br>C、问答环节可以为听众答疑解惑，因此只对听众有所帮助。</li><li>作为学术会议的听众，在问答环节提问时，不可取的做法是（）<br>D、在演讲过程中有疑问时随时提问。</li><li>下列不属于学术海报的特点的是（）<br>A、结构完整，论述详尽</li><li>下列关于学术海报的设计原则，错误的是（）<br>B、多用文字，少用图表</li><li>下列关于学术海报的叙述，正确的是（）<br>D、针对观众的不同，适当调整海报内容，展示研究中最重要的结论。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;font size=&quot;4&quot; color=&quot;00b9ff&quot;&gt;前言：章节答案由我自己整理，期末考试暂未更新&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;center-第一章-center&quot;&gt;&lt;center&gt;第一章&lt;/center&gt;&lt;/h2&gt;
&lt;ol</summary>
      
    
    
    
    <category term="课程答案" scheme="https://luotian.cyou/categories/%E8%AF%BE%E7%A8%8B%E7%AD%94%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo 自定义主题配置</title>
    <link href="https://luotian.cyou/post/custom-css4hexo.html"/>
    <id>https://luotian.cyou/post/custom-css4hexo.html</id>
    <published>2025-08-16T05:33:54.000Z</published>
    <updated>2025-08-16T05:40:29.640Z</updated>
    
    <content type="html"><![CDATA[<p>  记录一下小窝在配置过程中一些自定义的主题内容。</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 文字排版 */</span></span><br><span class="line"><span class="selector-id">#article-container</span>{</span><br><span class="line">      <span class="attribute">text-align</span>: justify;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改行内代码颜色 */</span></span><br><span class="line"><span class="selector-pseudo">:not</span>(pre) &gt; <span class="selector-tag">code</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FF5733</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通用响应式视频样式（自适应页面宽度） */</span></span><br><span class="line"><span class="selector-tag">iframe</span><span class="selector-attr">[src*=<span class="string">"youtube.com"</span>]</span>,</span><br><span class="line"><span class="selector-tag">iframe</span><span class="selector-attr">[src*=<span class="string">"youtu.be"</span>]</span>,</span><br><span class="line"><span class="selector-tag">iframe</span><span class="selector-attr">[src*=<span class="string">"vimeo.com"</span>]</span> {</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">aspect-ratio</span>: <span class="number">16</span> / <span class="number">9</span>;  <span class="comment">/* 自动保持 16:9 */</span></span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图片圆角 + 适配亮暗主题 */</span></span><br><span class="line"><span class="selector-class">.post-content</span> <span class="selector-tag">img</span> {</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">object-fit</span>: cover;</span><br><span class="line">    <span class="attribute">transition</span>: all <span class="number">0.3s</span> ease;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">html</span><span class="selector-class">.dark</span> <span class="selector-class">.post-content</span> <span class="selector-tag">img</span> {</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  记录一下小窝在配置过程中一些自定义的主题内容。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comme</summary>
      
    
    
    
    <category term="hexo博客" scheme="https://luotian.cyou/categories/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="https://luotian.cyou/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo 外链设置</title>
    <link href="https://luotian.cyou/post/exlinks4hexo.html"/>
    <id>https://luotian.cyou/post/exlinks4hexo.html</id>
    <published>2025-08-14T05:03:08.000Z</published>
    <updated>2025-08-14T06:14:52.366Z</updated>
    
    <content type="html"><![CDATA[<p>  我在部分文章中引入了较多的外链，而这些外链统一使用 md 语法<code>[链接文字](外链地址)</code>，这使得渲染得到的网页直接在本标签页打开外链，不仅影响阅读体验，还不利于网站安全和 SEO 优化。因此查阅相关资料并进行下面的优化调整。</p><h3 id="自定义配置">自定义配置</h3><p>  在非本站的外链中添加<code>target="_blank"</code>字段可新建标签页打开，添加<code>rel="noopener noreferrer"</code>字段可以阻止新开页面通过 <code>window.opener</code> 操作原页面，并防止 Referer 泄漏。<br>  基于上述原理，在 hexo 根目录下新建<code>/scripts/external-links.js</code>并写入：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">'after_post_render'</span>, <span class="keyword">function</span> (<span class="params">data</span>) {</span><br><span class="line">  <span class="keyword">const</span> siteHost = hexo.<span class="property">config</span>.<span class="property">url</span>.<span class="title function_">replace</span>(<span class="regexp">/https?:\/\//</span>, <span class="string">''</span>).<span class="title function_">replace</span>(<span class="regexp">/\/$/</span>, <span class="string">''</span>);</span><br><span class="line">  data.<span class="property">content</span> = data.<span class="property">content</span>.<span class="title function_">replace</span>(<span class="regexp">/&lt;a\s+([^&gt;]*href="([^"]+)"[^&gt;]*)&gt;/gi</span>, <span class="function">(<span class="params">match, attr, href</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 判断是否为外链</span></span><br><span class="line">      <span class="keyword">if</span> (!href.<span class="title function_">includes</span>(siteHost) &amp;&amp; !href.<span class="title function_">startsWith</span>(<span class="string">'#'</span>) &amp;&amp; !href.<span class="title function_">startsWith</span>(<span class="string">'/'</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (!<span class="regexp">/target=/</span>.<span class="title function_">test</span>(attr)) attr += <span class="string">' target="_blank"'</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="regexp">/rel=/</span>.<span class="title function_">test</span>(attr)) attr += <span class="string">' rel="noopener noreferrer"'</span>;</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">catch</span> (e) {}</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a <span class="subst">${attr}</span>&gt;`</span>;</span><br><span class="line">  });</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>  这样可以无需手动添加外链标签，而是在渲染阶段自动执行。重新部署生成，打开 public/ 文件夹里的文章 HTML，找到外链 <code>&lt;a&gt;</code> 标签，可以看到渲染成功：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener noreferrer"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="hexo插件配置">hexo 插件配置</h3><p>  也可以使用 hexo 插件对外链进行配置。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-external-link --save</span><br></pre></td></tr></tbody></table></figure><p>  在 Hexo 根目录的<code>_config.yml</code>文件中添加下面的配置：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">hexo_external_link:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable_base64_encode:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">url_param_name:</span> <span class="string">'u'</span></span><br><span class="line">  <span class="attr">html_file_name:</span> <span class="string">'go.html'</span></span><br><span class="line">  <span class="attr">target_blank:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">link_rel:</span> <span class="string">'external nofollow noopener noreferrer'</span></span><br><span class="line">  <span class="attr">domain:</span> <span class="string">'your_domain'</span> <span class="comment"># 如果开启了防盗链</span></span><br><span class="line">  <span class="attr">safety_chain:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">ignore_attrs:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">'data-fancybox'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'ignore-external-link'</span></span><br></pre></td></tr></tbody></table></figure><p>  各参数含义及配置说明参见原作者的项目 <a href="https://github.com/hvnobug/hexo-external-link" target="_blank" rel="noopener noreferrer">hexo-external-link</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  我在部分文章中引入了较多的外链，而这些外链统一使用 md 语法&lt;code&gt;[链接文字](外链地址)&lt;/code&gt;，这使得渲染得到的网页直接在本标签页打开外链，不仅影响阅读体验，还不利于网站安全和 SEO 优化。因此查阅相关资料并进行下面的优化调整。&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="hexo博客" scheme="https://luotian.cyou/categories/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="https://luotian.cyou/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>常用 conda 指令</title>
    <link href="https://luotian.cyou/post/conda-commands.html"/>
    <id>https://luotian.cyou/post/conda-commands.html</id>
    <published>2025-08-08T09:03:44.000Z</published>
    <updated>2025-08-14T06:05:02.561Z</updated>
    
    <content type="html"><![CDATA[<p>  记录一些常用的 conda 指令。</p><h3 id="1-环境配置">1. 环境配置</h3><ul><li><p>查看已有虚拟环境<br><code>conda env list</code></p><p><code>conda info -e</code></p></li><li><p>创建虚拟环境<br><code>conda create -n env_name python=x.x</code></p></li><li><p>激活虚拟环境<br><code>activate env_name</code></p></li><li><p>删除虚拟环境<br><code>conda remove -n env_name --all</code></p></li><li><p>切换回默认环境<br><code>deactivate env_name</code></p><p><code>activate base</code></p><p><code>activate</code></p></li><li><p>获得环境中的所有配置并导出<br><code>conda env export --name myenv &gt; myenv.yml</code></p></li><li><p>重新还原环境<br><code>conda env create -f myenv.yml</code></p></li></ul><h3 id="2-下载源配置">2. 下载源配置</h3><ul><li><p>添加清华园<br><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</code></p><p><code>conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</code></p><p><code>conda config --set show_channel_urls yes</code></p></li><li><p>查看下载源<br><code>conda config --show channels</code></p></li></ul><h3 id="3-包管理">3. 包管理</h3><ul><li><p>查看已安装的软件包<br><code>conda list</code></p></li><li><p>查询当前 conda 源中是否有指定的包<br><code>conda search package_name</code></p></li><li><p>查询是否安装了指定的包<br><code>conda list pkgname</code></p><p><code>conda list pkgname*</code></p></li><li><p>删除不再使用的包和缓存<br><code>conda clean --all</code></p></li><li><p>清除 pip 缓存<br><code>pip cache purge</code></p></li><li><p>清除特定软件包的缓存<br><code>pip cache remove package-name</code></p></li></ul><h3 id="4-其他">4. 其他</h3><ul><li>盘符切换（如 D 盘）<br><code>d:</code></li></ul><h3 id="5-友链">5. 友链</h3><ul><li><a href="https://www.bilibili.com/video/BV1Fm4ZzDEeY" target="_blank" rel="noopener noreferrer">15 分钟彻底搞懂！Anaconda Miniconda conda-forge miniforge Mamba</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  记录一些常用的 conda 指令。&lt;/p&gt;
&lt;h3 id=&quot;1-环境配置&quot;&gt;1. 环境配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看已有虚拟环境&lt;br&gt;
&lt;code&gt;conda env list&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;conda info -e&lt;/co</summary>
      
    
    
    
    <category term="深度学习" scheme="https://luotian.cyou/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="conda" scheme="https://luotian.cyou/tags/conda/"/>
    
  </entry>
  
  <entry>
    <title>hexo 配置 pangu—butterfly 主题</title>
    <link href="https://luotian.cyou/post/pangu4hexo.html"/>
    <id>https://luotian.cyou/post/pangu4hexo.html</id>
    <published>2025-07-30T11:01:14.000Z</published>
    <updated>2025-08-16T05:32:59.895Z</updated>
    
    <content type="html"><![CDATA[<p>  前言：不知道为什么有关这方面配置的博客很少，而且方法都不是很统一，因此做个记录。</p><h2 id="一、模块配置">一、模块配置</h2><p>  pangu（盘古）模块是一个渲染脚本，用于在博客的中英文、数字之间自动添加空格，使中英文文字混排变得美观。下面是<a href="https://github.com/vinta/pangu.js/" target="_blank" rel="noopener noreferrer">开源地址</a>和作者的碎碎念：</p><blockquote><p>汉学家称这个空白字元为「盘古之白」，因为它劈开了全形字和半形字之间的混沌。另有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。</p></blockquote><p>  我的 butterfly 主题版本是 4.9.0，在配置文件中找到<code>pangu</code>关键字并启用：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">pangu:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span> <span class="comment"># site/post</span></span><br></pre></td></tr></tbody></table></figure><p>  这里<code>site</code>表示全站启用，<code>post</code>表示仅 post 页面启用。有些博客到这里就 OK 了，但是我的配置并未成功，还需要安装 <a href="https://github.com/next-theme/hexo-pangu" target="_blank" rel="noopener noreferrer">hexo-pangu</a> 组件，这里并不直接安装 pangu 组件是因为需要进行魔改才能生效，比较麻烦。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-pangu</span><br></pre></td></tr></tbody></table></figure><p>  然后就能在页面中看到启用后的效果了。</p><h2 id="二、相关问题">二、相关问题</h2><p>  部署之后在控制台界面出现了<code>Uncaught SyntaxError: Cannot use import statement outside a module</code>的报错。具体报错代码在<code>pangu.min.js</code>中第 7 行：</p><figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> {<span class="title class_">Pangu</span>} <span class="keyword">from</span> <span class="string">"../shared/index.js"</span>;</span><br></pre></td></tr></tbody></table></figure><p>  大概意思是这个 js 文件使用了 ES6 的 import 语法，而浏览器默认不支持。解决方法可以将 pangu.min.js 设置为模块引入，或者将 js 本地重构，转换为浏览器可执行的 JavaScript。<br>  经过搜索找到了 pangu 官方使用 UMD 构建的版本，可以兼容 script 引入：</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/pangu@7.2.0/dist/browser/pangu.umd.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>  由于 jsdelivr 国内访问不稳定，我将其部署在了本地，这样部署后就不会出现报错了：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line">  <span class="attr">pangu:</span> <span class="string">/js/pangu.umd.js</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  前言：不知道为什么有关这方面配置的博客很少，而且方法都不是很统一，因此做个记录。&lt;/p&gt;
&lt;h2 id=&quot;一、模块配置&quot;&gt;一、模块配置&lt;/h2&gt;
&lt;p&gt;  pangu（盘古）模块是一个渲染脚本，用于在博客的中英文、数字之间自动添加空格，使中英文文字混排变得美观。下面是&lt;</summary>
      
    
    
    
    <category term="hexo博客" scheme="https://luotian.cyou/categories/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="https://luotian.cyou/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>KMP 算法</title>
    <link href="https://luotian.cyou/post/KMP-Algorithm.html"/>
    <id>https://luotian.cyou/post/KMP-Algorithm.html</id>
    <published>2025-07-23T12:55:58.000Z</published>
    <updated>2025-07-30T10:33:35.969Z</updated>
    
    <content type="html"><![CDATA[<p>  KMP 算法 —— 用于字符串匹配。优点是在匹配的过程中不用回退主指针，子指针会根据子串中最长相等前后缀来进行回退，能够大大降低时间复杂度。<br>  这里有几个定义需要说明：</p><ul><li>前缀：不包含尾字符的所有子串</li><li>后缀：不包含首字符的所有子串</li></ul><p>  举例：<strong>T = aabaaf</strong></p><table><thead><tr><th style="text-align:center">子串</th><th style="text-align:center">说明</th><th style="text-align:center">最长相等前后缀的长度</th></tr></thead><tbody><tr><td style="text-align:center">$t_1=\mathrm{a}$</td><td style="text-align:center">无前缀也无后缀</td><td style="text-align:center">$\pi \left( 0 \right) =0$</td></tr><tr><td style="text-align:center">$t_1=\mathrm{aa}$</td><td style="text-align:center">前缀为 $\small {\mathrm {a}}$ 后缀也为 $\small {\mathrm {a}}$</td><td style="text-align:center">$\pi \left( 1 \right) =1$</td></tr><tr><td style="text-align:center">$t_1=\mathrm{aab}$</td><td style="text-align:center">前缀一定无 $\small {\mathrm {b}}$ 后缀一定有 $\small {\mathrm {b}}$</td><td style="text-align:center">$\pi \left( 2 \right) =0$</td></tr><tr><td style="text-align:center">$t_1=\mathrm{aaba}$</td><td style="text-align:center">最大相等前后缀为 $\small {\mathrm {a}}$</td><td style="text-align:center">$\pi \left( 3 \right) =1$</td></tr><tr><td style="text-align:center">$t_1=\mathrm{aabaa}$</td><td style="text-align:center">最大相等前后缀为 $\small {\mathrm {aa}}$</td><td style="text-align:center">$\pi \left( 4 \right) =2$</td></tr><tr><td style="text-align:center">$t_1=\mathrm{aabaaf}$</td><td style="text-align:center">无最大相等前后缀</td><td style="text-align:center">$\pi \left( 5 \right) =0$</td></tr></tbody></table><table><thead><tr><th style="text-align:center">$\mathrm{j}$</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">$T$</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">a</td><td style="text-align:center">a</td><td style="text-align:center">f</td></tr><tr><td style="text-align:center">$\pi(T)$</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table><p>  一般也把 $\small {\pi (T)}$ 叫做前缀表，前缀表中保存的元素就是子指针回退的位置。编程实现中，也叫 next 数组。具体计算如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NextTable</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; next, string s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[j] != s[i]) j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-28">力扣 28</h2><p>  <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" target="_blank" rel="noopener noreferrer">找出字符串中第一个匹配项的下标</a><br>  这个题目就是一道经典的匹配问题，暴力解法同时遍历 haystack 和 needle，时间复杂度为 $\small {O (M * N)}$，空间复杂度为 $\small {O (1)}$：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>;<span class="comment">// 如果匹配失败返回 -1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;haystack.<span class="built_in">size</span>();)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; needle.<span class="built_in">size</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 如果匹配到相同字符，j++，k++</span></span><br><span class="line">            <span class="keyword">if</span>(haystack[j++] == needle[k])</span><br><span class="line">                k++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果没有直接退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果上一步循环得到的 k 等于 needle 大小，说明 needle 得到完全匹配</span></span><br><span class="line">        <span class="keyword">if</span>(k == needle.<span class="built_in">size</span>()) </span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 直接作差（此时 j 和 k 没有起始下标偏差，直接做差）</span></span><br><span class="line">            i = j - k;</span><br><span class="line">            <span class="comment">// 跳出遍历</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果没有匹配到，则回退 j 到本次匹配 第一个匹配相同的位置 的下一个</span></span><br><span class="line">        j = j - k;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  如果用 KMP 算法，时间复杂度为 $\small {O (M + N)}$，空间复杂度为 $\small {O (M)}$。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 创建 next 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(needle.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; needle.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(needle[i] == needle[j]) j++;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(haystack[i] == needle[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == needle.<span class="built_in">size</span>()) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  可以发现 KMP 算法无论是创建前缀表还是应用前缀表，代码具有高度相似性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  KMP 算法 —— 用于字符串匹配。优点是在匹配的过程中不用回退主指针，子指针会根据子串中最长相等前后缀来进行回退，能够大大降低时间复杂度。&lt;br&gt;
  这里有几个定义需要说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀：不包含尾字符的所有子串&lt;/li&gt;
&lt;li&gt;后缀：不包含首字</summary>
      
    
    
    
    <category term="算法" scheme="https://luotian.cyou/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串" scheme="https://luotian.cyou/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题 - 字符串</title>
    <link href="https://luotian.cyou/post/leetcode-String.html"/>
    <id>https://luotian.cyou/post/leetcode-String.html</id>
    <published>2025-07-23T09:49:01.000Z</published>
    <updated>2025-07-30T10:41:41.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-344">力扣 344</h2><p>  <a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener noreferrer">反转字符串</a><br>  双指针秒了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// swap(s[left++], s[right--]);</span></span><br><span class="line">        <span class="type">char</span> temp = s[left];</span><br><span class="line">        s[left++] = s[right];</span><br><span class="line">        s[right--] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-541">力扣 541</h2><p>  <a href="https://leetcode.cn/problems/reverse-string-ii/" target="_blank" rel="noopener noreferrer">反转字符串 Ⅱ</a><br>  很简单的一道题，但是很容易写复杂。这里关键让 i 每次步进 2 * k，后面的逻辑就很清楚了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// i 每次步进 2 * k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 反转前 k 个，所以这里是可以取等号的</span></span><br><span class="line">        <span class="keyword">if</span>(i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="comment">// 自建函数是左闭右闭的，所以这里要减去 1</span></span><br><span class="line">            <span class="built_in">reverseChar</span>(s, i, i + k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 剩余字符串小于 k，全部反转</span></span><br><span class="line">            <span class="built_in">reverseChar</span>(s, i, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseChar</span><span class="params">(string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        <span class="built_in">swap</span>(s[left++], s[right--]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  如果使用 reverse 函数，则：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// i 每次步进 2 * k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 反转前 k 个，所以这里是可以取等号的</span></span><br><span class="line">        <span class="keyword">if</span>(i + k &lt;= s.<span class="built_in">size</span>())</span><br><span class="line">            <span class="comment">// reverse函数是左闭右开的，所以这里不用减 1</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 剩余字符串小于 k，全部反转</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">end</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-151">力扣 151</h2><p>  <a href="https://leetcode.cn/problems/reverse-words-in-a-string/" target="_blank" rel="noopener noreferrer">反转字符串中的单词</a><br>  可以使用双指针解答这道题。题目说每个单词之间都有空格，那就在 s 的末尾再加一个空格，确保每个单词后都有空格。定义指针 fast 和 slow，开始逆向遍历，当 fast - 1 处是空格且 fast 处不是空格，或者 fast 为 0 且 fast 处不是空格，那么就找到了单词开头。然后更新 slow，确保 slow 处是空格但是 slow- 1 处不是空格，[fast, slow] 范围内即是一个完整的单词 + 一个空格。将 [fast, slow] 范围保存，更新 slow = fast - 1。<br>  不过上面逻辑会使得结果末尾出现空格，使用 while 循环删除即可得到最终结果。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string words;</span><br><span class="line">    s = s + <span class="string">' '</span>;</span><br><span class="line">    <span class="type">int</span> fast = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> slow = fast;</span><br><span class="line">    <span class="keyword">while</span>(fast &gt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(s[fast] != <span class="string">' '</span> &amp;&amp; (fast == <span class="number">0</span> || s[fast - <span class="number">1</span>] == <span class="string">' '</span>))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(s[slow - <span class="number">1</span>] == <span class="string">' '</span>)</span><br><span class="line">                slow--;</span><br><span class="line">            words.<span class="built_in">append</span>(s.<span class="built_in">begin</span>() + fast, s.<span class="built_in">begin</span>() + slow + <span class="number">1</span>);</span><br><span class="line">            slow = fast - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        fast--;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(words[words.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">' '</span>)</span><br><span class="line">        words.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> words;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-344&quot;&gt;力扣 344&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://leetcode.cn/problems/reverse-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;反转字符串&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://luotian.cyou/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="字符串" scheme="https://luotian.cyou/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>hexo 全局配置文章对齐方式</title>
    <link href="https://luotian.cyou/post/hexo-text-align.html"/>
    <id>https://luotian.cyou/post/hexo-text-align.html</id>
    <published>2025-07-21T14:18:23.000Z</published>
    <updated>2025-08-14T06:08:13.018Z</updated>
    
    <content type="html"><![CDATA[<p>  编写文章的时候发现正文内容没有两端对齐，每段文字末尾没对齐看着不是很美观。这里总结一下配置教程。</p><p>  首先 hexo + butterfly 框架下文章内容的类名叫做 <code>article-container</code> 。然后只需要在用户自定义的 <code>custom.css</code> 中写入如下的内容即可：</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-id">#article-container</span>{</span><br><span class="line">    <span class="attribute">text-align</span>: justify;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  其中 <code>text-align</code> 字段定义文字的对齐方式，常用取值如下：</p><ul><li><code>left</code>：左对齐（默认）</li><li><code>right</code>：右对齐</li><li><code>center</code>：居中对齐</li><li><code>justify</code>：两端对齐</li></ul><p>  custom.css 文件路径一般在 your_blog_root_dir\themes\butterfly\source\css 下新建即可，然后在主题配置文件_config.butterfly.yml 里找到<code>inject</code>字段并插入：</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel="stylesheet"</span> <span class="string">href="/css/custom.css"&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  编写文章的时候发现正文内容没有两端对齐，每段文字末尾没对齐看着不是很美观。这里总结一下配置教程。&lt;/p&gt;
&lt;p&gt;  首先 hexo + butterfly 框架下文章内容的类名叫做 &lt;code&gt;article-container&lt;/code&gt; 。然后只需要在用户自定义的</summary>
      
    
    
    
    <category term="hexo博客" scheme="https://luotian.cyou/categories/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="https://luotian.cyou/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题 - 链表</title>
    <link href="https://luotian.cyou/post/leetcode-Linklist.html"/>
    <id>https://luotian.cyou/post/leetcode-Linklist.html</id>
    <published>2025-07-18T11:22:47.000Z</published>
    <updated>2025-07-30T10:41:54.091Z</updated>
    
    <content type="html"><![CDATA[<p>  对于一个链表，C++ 的定义如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> {</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) {}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>  链表结构可由下表征：</p><p><img src="https://raw.githubusercontent.com/LuoTian001/piclist/master/files/linklist.jpg" alt=""></p><h2 id="力扣-203">力扣 203</h2><p>  <a href="https://leetcode.cn/problems/remove-linked-list-elements/" target="_blank" rel="noopener noreferrer">移除链表元素</a><br>  这个题由于涉及到头节点的变动，因此可以先设置一个空的前置节点 dummy，然后将 dummy 指向 head。为了对 dummy 的指针指向进行保留，这里复制一个指针 temp = dummy。接下来是两种情况，当 temp-&gt;next-&gt;val == val，那么 temp-&gt;next = temp-&gt;next-&gt;next。否则 temp 指针移动，temp = temp-&gt;next。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>* temp = dummy;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next-&gt;val == val)</span><br><span class="line">        {</span><br><span class="line">            temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度为 $\small {O (n)}$，空间复杂度为 $\small {O (1)}$。</p><h2 id="力扣-707">力扣 707</h2><p>  <a href="https://leetcode.cn/problems/design-linked-list/" target="_blank" rel="noopener noreferrer">设计链表</a></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化链表，大小为 0 ，头结点的值为 0</span></span><br><span class="line">    <span class="comment">// this指针用于访问类的成员变量和成员函数</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() {</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获得指定节点的值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="comment">// 这里 &gt;= size 是因为元节点的下标是 0，末尾节点的下标是 size - 1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 定义一个指针 cur 指向头结点，这样不会改变head中的值</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="comment">// 遍历链表，直到遍历下标为 index 的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= index; i++)</span><br><span class="line">        {</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在 0 位置添加节点，就相当于在头部添加节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="number">0</span>, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在 size 位置添加节点，就相当于在末尾添加节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="built_in">addAtIndex</span>(size, val);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在index处添加节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="comment">// 如果 index 大于 size，则不添加节点</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果 index 小于 0，则将 index 置为 0</span></span><br><span class="line">        index = <span class="built_in">max</span>(<span class="number">0</span>, index);</span><br><span class="line">        <span class="comment">// 添加节点，size++</span></span><br><span class="line">        size++;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="comment">// 定位到 index 前一个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        {</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 添加新的节点</span></span><br><span class="line">        ListNode* NewNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        <span class="comment">// 插入新的节点</span></span><br><span class="line">        NewNode-&gt;next = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = NewNode;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="comment">//这里取 &gt;= 是因为元节点下标是 0</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        size--;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        {</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListNode* p = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 释放被删除节点的内存</span></span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> {</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode* next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) {}</span><br><span class="line">    };</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode* head;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-206">力扣 206</h2><p>  <a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener noreferrer">反转链表</a><br>  这个题可以用双指针的解法。设定慢指针 slow = NULL，快指针 fast = head。现在开始遍历。设置 temp = fast-&gt;head，保存 fast 的下一个节点。这里为了反转链表，需要将 fast-&gt;next 指向上一个节点 slow，因此有 fast-&gt;next = slow。现在反转了链表。开始移动 fast 和 slow 指针。这里先移动 slow 指针，由于现在 slow 已经完成任务，slow 需要向右移动一位，也就是 slow = fast。然后 fast 也向右移动一位，也就是 fast = temp。这一轮的反转就完成了。<br>  由于 fast 比 slow 快一格，而题目要求要返回反转后的头节点，所以 fast 要遍历到原链表的 NULL 处。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ListNode* slow = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        ListNode* temp = fast-&gt;next;</span><br><span class="line">        fast-&gt;next = slow;</span><br><span class="line">        slow = fast;</span><br><span class="line">        fast = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-24">力扣 24</h2><p>  <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener noreferrer">两两交换链表中的节点</a><br>  这个题说了两两交换，那么只研究前两个节点之间的连接关系就行。为了让节点访问更方便，还是要在链表前插入一个虚拟头节点 dummy。那么对于 dummy 和 node1 和 node2，两两交换就是将节点 dummy-&gt;node1-&gt;node2 变成 dummy-&gt;node2-&gt;node1，其他两两节点可依此类推。设定节点 temp = dummy，想完成交换，首先让 temp -&gt; node2，然后 node1 -&gt; node3，最后 node2 -&gt; node1。然后更新 temp 向右移动两个节点，也就是 temp = node1（此时 node1 已经成为了链表中第二个节点），开始下一轮循环。循环的终止条件需要注意，要把 temp-&gt;next != NULL 放在前面，不然如果 temp-&gt;next == NULL，temp-&gt;next-&gt;next 就是非法访问，会编译出错。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 节点 0</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    ListNode* temp = dummy;</span><br><span class="line">    <span class="comment">// 第一个说明当链表是偶数个节点，第二个说明当链表是奇数个节点</span></span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//节点 1</span></span><br><span class="line">        ListNode* node1 = temp-&gt;next;</span><br><span class="line">        <span class="comment">//节点 2</span></span><br><span class="line">        ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">//节点 dummy -&gt; 节点 2</span></span><br><span class="line">        temp-&gt;next = node2;</span><br><span class="line">        <span class="comment">//节点 1 -&gt; 节点 3</span></span><br><span class="line">        node1-&gt;next = node2-&gt;next;</span><br><span class="line">        <span class="comment">//节点 2 -&gt; 节点 1</span></span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        <span class="comment">//节点 temp = 节点 1 （步进两个节点）</span></span><br><span class="line">        temp = node1;</span><br><span class="line">    }</span><br><span class="line">    ListNode* res = dummy-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> dummy;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-19">力扣 19</h2><p>  <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener noreferrer">删除链表倒数第 N 个节点</a><br>  这个题乍一看需要遍历两遍链表，第一遍遍历得到链表的大小，第二遍遍历得到需要删除的元素的位置。不过可以换个思路，将两个遍历合并成一个。这里需要用到双指针的策略。首先定义 fast 和 slow 指针，刚开始先移动 fast 指针，让 fast 和 slow 的距离为 n 个节点。然后开始同步移动 fast 和 slow，当 fast 的下一位是 NULL 时，此时 slow 的下一位就是要删除的节点，这个时候就只需要 slow-&gt;next = slow-&gt;next-&gt;next 即可删除节点。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 定义快慢指针</span></span><br><span class="line">    ListNode* fast = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    ListNode* slow = fast;</span><br><span class="line">    <span class="comment">// 定义临时头节点</span></span><br><span class="line">    ListNode* dummy = fast;</span><br><span class="line">    <span class="comment">// 如果 n &lt;= 0 无效</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 开始移动 fast 指针，当移动 n 步后停止</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> count = <span class="number">1</span>; count &lt;= n; count++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果 fast 下一位为空但是遍历次数还没达到 n 次说明 n 的大小超过链表大小，访问无效</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &lt; n)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> slow-&gt;next;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 开始同步移动 fast 和 slow，如果 fast 的下一位为 NULL，说明到了链表末尾。此时 slow 的下一位就是要删除的节点</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    ListNode* temp = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    <span class="comment">// 返回链表头节点</span></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  时间复杂度为 $\small {O (L)}$，$\small {L}$ 为链表长度。空间复杂度为 $\small {O (1)}$。</p><h2 id="力扣-142">力扣 142</h2><p>  <a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noopener noreferrer">环形链表 Ⅱ</a><br>  判断链表中有没有环，可以近似成操场跑圈的相遇问题。假设有两个人同时起跑，一个人快，一个人慢，那么经过一段时间，他们一定可以在操场上的某个位置相遇。那么对于这个题目，定义一个快指针 fast 和一个慢指针 slow ，慢指针每次移动一格，快指针每次移动两格，如果链表存在环，他们必定会在环中相遇，如果链表不存在环，他们不可能相遇。<br>  解决了链表中是否有环的问题，接下来解决如何找到环的入口。定义进入环之前的路程为 $\small {a}$，slow 进入环后走了 $\small {b}$ 路程和 fast 相遇，环的路程为 $\small {b + c}$，那么可以得知在 slow 进入环前 fast 已经在环内行走了 $\small {n (b + c)}$ 的路程，其中有 $\small {n\geqslant 1,n\in \mathbf {N}_+}$。根据上面的条件，列出等式：<br>$$a+b=\frac{a+n\left( b+c \right) +b}{2}$$<br>  化简后得：<br>$$a=\left( n-1 \right) \left( b+c \right) +c$$<br>  这表明 slow 走过 $\small {n-1}$ 个完整的环后，再走过路程 $\small {c}$ 必定和路程 $\small {a}$ 相等。因此定义一个新的指针 index = head，index 和 slow 每次步进 1 个节点，那么相遇的节点就是环的入口。<br><img src="https://raw.githubusercontent.com/LuoTian001/piclist/master/files/cirlist.jpg" alt=""></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ListNode* fast = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    ListNode* slow = fast;</span><br><span class="line">    <span class="comment">// 这里要确保fast接下来的两个节点都不为空</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 这里要先进行指针移动，否则初始条件下 fast == slow 会出问题</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast-&gt;next == slow-&gt;next)</span><br><span class="line">        {</span><br><span class="line">            ListNode* index = head;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(index != slow)</span><br><span class="line">            {</span><br><span class="line">                index = index-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 链表没有环，返回空指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-15">力扣 15</h2><p>  <a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener noreferrer">三数之和</a><br>  这个题用哈希表做会变得非常麻烦，还是得用双指针的方法。设定 i、left、right 分别对应三个数的元素下标，取值为：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>  这里没有说返回的数组是有序的，那么可以先对数组从小到大进行排序，然后再遍历数组，这样做是因为三数相加为 0，也就是 $\small {a + b+c = 0}$，$\small {a\leqslant b\leqslant c}$。那么一定有 $\small {a\leqslant 0}$，因此有了第一个判断条件，如果 nums [i] &gt; 0，直接返回结果，不用再遍历了。<br>  然后对 $\small {a}$ 进行去重，为了说明去重的必要性，举例 [-1, -1, -1, 0, 1]，可以看到结果是 [-1, 0, 1]，但是 - 1 会有多个不同的取值。在这里就需要判断，如果当 i 元素和 i - 1 元素值相同，那么就跳过此轮遍历。<br>  然后添加 while 循环，判断三数之和是否为 0，如果大于 0，说明 nums [right] 太大了，将 right- -，如果小于 0，说明 nums [left] 太小了，将 left++。如果三数之和等于 0，那么就保存 i、left、right 对应元素值。<br>  这个时候我们还要注意，如果有这样的情况 [-1, -1, 0, 0, 1, 1]，多个 left 和 right 满足要求，就需要对 left 和 right 进行去重。在等于 0 的判断下，添加 while 循环，当 right 和 right - 1 元素相等，right- -，当 left 和 left + 1 元素相等，left++。这里注意无论是否进入去重的 while 循环，最后都要更新 right 和 left。<br>  所有 while 循环都要加上 right &gt; left 条件防止出错。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span><br><span class="line">{</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt; left)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[i], nums[left], nums[right]});</span><br><span class="line">                <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                right--;</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>时间复杂度是 $\small {O (N^2)}$。</p><h2 id="力扣-18">力扣 18</h2><p>  <a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener noreferrer">四数之和</a><br>  这个题目和三数之和原理一致，也是使用双指针的方法，不过由于这个题目是 4 数相加，而且 target 是任意值，在去重方面还是有些不一致。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span><br><span class="line">{</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 第一次剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(nums[k] &gt; target &amp;&amp; (nums[k] &gt;= <span class="number">0</span> || target &gt;= <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// 终止循环</span></span><br><span class="line">        <span class="comment">// 对 k 去重，原理和上一题 i 去重一样</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 第二次剪枝</span></span><br><span class="line">            <span class="comment">// 如果前两数大于 target，且 nums[i] 大于 0，后面的数再加一定大于零，直接终止循环</span></span><br><span class="line">            <span class="keyword">if</span>(nums[k] + nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 对 i 去重，原理和上一题 i 去重一样</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; i &gt; k + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 下面代码逻辑不变</span></span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// 要转成long，不然会溢出</span></span><br><span class="line">                <span class="keyword">if</span>((<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right] &gt; target) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right] &lt; target) left++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;{nums[k], nums[i], nums[left], nums[right]});</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  对于一个链表，C++ 的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;st</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://luotian.cyou/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="链表" scheme="https://luotian.cyou/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题 - 数组</title>
    <link href="https://luotian.cyou/post/leetcode-Array.html"/>
    <id>https://luotian.cyou/post/leetcode-Array.html</id>
    <published>2025-07-17T11:58:35.000Z</published>
    <updated>2025-07-30T10:41:49.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-704">力扣 704</h2><p>  <a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noopener noreferrer">二分查找</a><br>  这道题目可以用暴力解法，也就是遍历数组元素，但是这样做的时间复杂度是 $\small {O (N)}$。因此可以采取二分法对题目进行求解。设定开始查找的范围为 [left, right]，比较区间中点 mid 的值和 target 的大小，如果小于 target 说明 target 在 [mid + 1, right] 之间，如果大于 target 说明 target 在 [left, mid - 1] 之间。每轮根据区间修改 left 或 right 的值，如果 left &gt; right，说明数组中没有 target 目标值，返回 - 1。知道了二分法的原理，编写下面的代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="type">int</span> num = nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(num == target)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; target)</span><br><span class="line">        {</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  时间复杂度为 $\small {O (\mathrm {log}(N))}$。</p><h2 id="力扣-27">力扣 27</h2><p>  <a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener noreferrer">移除元素</a><br>  这个题目可以用双指针的方法进行解答。假定现在有两个指针，一个叫 slow，一个叫 fast，他们起始都指向数组 nums 的第一个元素 nums [0]，然后判定 nums [fast] 是否与 val 相等，如果相等，fast++，如果不相等就把 nums [fast] 的值给 nums [slow]，fast++，slow++。可以看到，这个操作实际上就是将非 val 的元素向前挪动，覆盖掉值为 val 的元素。这样无论 nums 数组后的元素是什么，只要保证返回的前 k 个元素不包含 val 就行。因此循环判定的条件就是 fast &lt; nums.size()。代码编写如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(nums[fast] != val)</span><br><span class="line">        {</span><br><span class="line">            nums[slow++] = nums[fast++];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> fast++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  时间复杂度为 $\small {O (N)}$，空间复杂度为 $\small {O (1)}$。</p><h2 id="力扣-977">力扣 977</h2><p>  <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener noreferrer">有序数组的平方（双指针）</a><br>  这个题可以直接先平方后 sort 排序的方法，但是这样做的时间复杂度为 $\small {O (n\mathrm {log} n)}$，空间复杂度为 $\small {O (\mathrm {log} n)}$。代码如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        nums[i] *= nums[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  其实也可以采用双指针的办法。题目告诉了数组是有序的，那么设定指针 left 和指针 right，并新建一个数组 res，大小和 nums 一样。left 指向 nums 第一个元素，right 指向 nums 的最后一个元素。如果 nums [left]^2 &gt; nums [right]^2，那么就把 left 的运算结果给 res 最右侧未被赋值的元素 k，此时 left++，k- -。同理，当 nums [left]^2 &lt; nums [right]^2 ，那么就把 right 的运算结果给 res 最右侧并 right- -，k- -。以此类推。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> k = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(nums[left] * nums[left] &lt;= nums[right] * nums[right])</span><br><span class="line">        {</span><br><span class="line">            res[k--] = nums[right] * nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            res[k--] = nums[left] * nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  时间复杂度为 $\small {O (n)}$，空间复杂度为 $\small {O (1)}$。</p><h2 id="力扣-209">力扣 209</h2><p>  <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener noreferrer">长度最小的子数组（双指针）</a><br>  这个题目可以用滑窗思想进行求解，仍然可以采用双指针，一个起始指针 i 和末尾指针 j，以示例 1 为例。开始 i 和 j 都指向 nums [0]，然后 j++，统计 i 和 j 之间元素和 sum。当 j = 3 时，sum = 8 &gt; 7，此时长度为 res = 4。为了找到最小的长度，令 i++，sum = 6，不符合要求。此时 j++，开启下一轮的查找。此时 sum = 10，res = 4，令 i++，sum = 7，res = 3；i++，sum = 6，不符合要求…… 以此类推，直到当 i = 5，j = 6，sum = 7，res = 2。得到最后结果。代码实现如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> res = INT32_MAX;<span class="comment">//设置窗口最大值，以方便比较</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> windsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++&gt;)</span><br><span class="line">    {</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)</span><br><span class="line">        {</span><br><span class="line">            windsize = j - i + <span class="number">1</span>;</span><br><span class="line">            res = res &gt; windsize ? windsize : res;</span><br><span class="line">            sum -= nums[i++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res == INT32_MAX ? <span class="number">0</span> : res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-59">力扣 59</h2><p>  <a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank" rel="noopener noreferrer">螺旋矩阵 Ⅱ</a><br>  这个题的难点在于如何编程实现螺旋顺序的矩阵元素访问。这里假设矩阵的四个顶点分别为 left_Top (Lt)、left_Bottom (Lb)、Right_Top (Rt)、Right_Bottom (Rb)，并将他们的值设置为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">int Lt = 0;</span><br><span class="line">int Lb = n - 1;</span><br><span class="line">int Rt = 0;</span><br><span class="line">int Rb = n - 1;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://raw.githubusercontent.com/LuoTian001/piclist/master/files/matrix.jpg" alt=""></p><p>  设定<font color="#d35400"> Lt</font> 方向为 <font color="#d35400">→</font> ，<font color="#27ae60"> Rt ↓ </font>，<font color="#3498db"> Rb ← </font> ，<font color="#fb5dd2"> Lb ↑ </font> 。这里四个顶点的坐标并不重要，重要的是这四个顶点标明了矩阵的旋转方向和坐标边界值。下面对坐标边界值进行说明。<br>  设定 Lt 和 Rb 是两个相对方向，那么列方向上坐标边界值就是 Lt = 0 和 Rb = n - 1。同理，Lb 和 Rt 是另外两个相对的方向，行方向上坐标边界值就是 Rt = 0，Lb = n - 1。<br>  知道了这些条件，现在加入一个变量 i：</p><ol><li>起始时 Lt → Rb（虽然实际上是 Lt → Rt，但 Lt 和 Rb 是左右两个相对方向），矩阵遍历下标为 [Rt][i]，因为这里相当于是 “ 行 = Rt = 0 ” 是定值，“列 = i = Lt → Rb ” 是变值。当列遍历完成，Rt++，相当于第 0 行现在已经填充好了元素，因此 Rt 需要向下移动一行。</li><li>第二步 Rt → Lb（虽然实际上是 Rt → Rb，但 Rt 和 Lb 是上下两个相对方向），矩阵遍历下标为 [i][Rb]，因为这里相当于是 “ 列 = Rb = n - 1 ” 是定值，“行 = i = Rt → Lb ” 是变值。当列遍历完成，Rb- -，相当于第 n - 1 列现在已经填充好了元素，因此 Rb 需要向左移动一行。</li><li>第三步 Rb → Lt，[Lb][i]，Lb- -。</li><li>第四步 Lb → Rt，[i][Lt]，Lt++。</li><li>当矩阵填充值大于 $\small {n \times n}$ 说明已经填充完毕，退出循环。</li></ol><p>  通过上述步骤就实现了矩阵的螺旋顺序访问。这个原理不仅可以用于顺时针，还可以用于逆时针。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n)</span><br><span class="line">{</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="type">int</span> Lt = <span class="number">0</span>, Lb = n - <span class="number">1</span>, Rt = <span class="number">0</span>, Rb = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> flag = n * n;</span><br><span class="line">    <span class="keyword">while</span>(count &lt;= flag)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = Lt; i &lt;= Rb; i++)</span><br><span class="line">        {</span><br><span class="line">            res[Rt][i] = count++;</span><br><span class="line">        }</span><br><span class="line">        Rt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = Rt; i &lt;= Lb; i++)</span><br><span class="line">        {</span><br><span class="line">            res[i][Rb] = count++;</span><br><span class="line">        }</span><br><span class="line">        Rb--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = Rb; i &gt;= Lt; i--)</span><br><span class="line">        {</span><br><span class="line">            res[Lb][i] = count++;</span><br><span class="line">        }</span><br><span class="line">        Lb--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = Lb; i &gt;= Rt; i--)</span><br><span class="line">        {</span><br><span class="line">            res[i][Lt] = count++;</span><br><span class="line">        }</span><br><span class="line">        Lt++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-704&quot;&gt;力扣 704&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://leetcode.cn/problems/binary-search/&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;二分查找&lt;/a&gt;&lt;br</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://luotian.cyou/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="数组" scheme="https://luotian.cyou/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题 - 哈希表</title>
    <link href="https://luotian.cyou/post/leetcode-HashTable.html"/>
    <id>https://luotian.cyou/post/leetcode-HashTable.html</id>
    <published>2025-07-17T08:14:22.000Z</published>
    <updated>2025-07-30T10:41:43.186Z</updated>
    
    <content type="html"><![CDATA[<p>  哈希表就是在关键字和存储位置之间建立对应关系。也就是：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden="">  flowchart LR    A["关键字"] --&gt; B["存储地址"]    A@{ shape: rounded}    B@{ shape: rounded}    classDef default stroke-width:3px,font-size:16px,fill:transparent  </pre></div><p>  在 C++ 中可以使用无序容器来实现：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">// 定义，这里表示key和value都是int型</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map = {{<span class="number">1</span>, <span class="number">1</span>}, {<span class="number">2</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>}};</span><br><span class="line"><span class="comment">// 也可以指定key的类型</span></span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="comment">// 如果没有指定元素，则map初始化的value为0</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">map.<span class="built_in">begin</span>();</span><br><span class="line">map.<span class="built_in">end</span>();</span><br><span class="line"><span class="comment">// 添加 key 并统计重复的key个数</span></span><br><span class="line">map[key]++;</span><br><span class="line"><span class="comment">// 添加 key 并去重</span></span><br><span class="line">map[key];</span><br><span class="line"><span class="comment">// 添加指定的key和value</span></span><br><span class="line">map[key] = value;</span><br><span class="line"><span class="comment">// 查找key（迭代器方式查找）</span></span><br><span class="line">map.<span class="built_in">find</span>(target);</span><br><span class="line"><span class="comment">// 返回指定key下的value</span></span><br><span class="line"><span class="type">int</span> value = map[key];</span><br></pre></td></tr></tbody></table></figure><p>  可以看到 map [key] 既可以左赋值也可以右赋值，很灵活。</p><h2 id="力扣-1">力扣 1</h2><p>  <a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noopener noreferrer">两数之和</a><br>  在这里，对于一个固定值 target，我要找到数组中的对应元素以及他们的下标，那就先建立起数组元素 key 和他们下标 value 的映射，这样就构建出了一个哈希表 map，map 用来存放遍历过的元素，比如示例 1，当开始遍历元素 2 时，我想找到 7 是否遍历过，因为 9-2 = 7，但是发现没有，因此更新哈希表，将 key = 2 和 value = 0 放进 map 表中，然后开始遍历 7，在 map 中找有没有元素 2，如果找到了，返回 map 中 {2， 0} 集合，取 value = 0 和 value = 1，即构成了示例 1 的答案。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; idx;<span class="comment">//构建&lt;key, value&gt;容器集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">auto</span> it = idx.<span class="built_in">find</span>(target - nums[i]);<span class="comment">//查找有没有target - nums[i]</span></span><br><span class="line">        <span class="keyword">if</span>(it != idx.<span class="built_in">end</span>())<span class="comment">//如果找到了</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> {it-&gt;second, i};<span class="comment">//it-&gt;second是在取value</span></span><br><span class="line">        }</span><br><span class="line">        idx[nums[i]] = i;<span class="comment">//更新哈希表</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> {};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  使用哈希表的时间复杂度为 $\small {O (N)}$，空间复杂度为 $\small {O (N)}$。比暴力解法 $\small {O (N^2)}$ 要快。</p><h2 id="力扣-242">力扣 242</h2><p>  <a href="https://leetcode.cn/problems/valid-anagram/" target="_blank" rel="noopener noreferrer">有效的字母异位词</a><br>  这个题使用数组作为哈希表。由于 s 和 t 仅包含小写字母，可以统计两个字符串中 26 个小写字母出现的次数。如果 s 和 t 中 26 个字母出现的次数相等，说明 t 是 s 的字母异位词，如果不相等则不是。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 判断长度是否相等，不相等一定不是字母异位词。</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">length</span>() != t.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 定义一个全零的一维数组，大小为26。</span></span><br><span class="line">    <span class="type">int</span> table[<span class="number">26</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="comment">// 统计s中26个字母出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it: s)</span><br><span class="line">        table[it - <span class="string">'a'</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it: t)</span><br><span class="line">    <span class="comment">// 统计t中26个字母出现的次数（做差）</span></span><br><span class="line">        table[it - <span class="string">'a'</span>]--;</span><br><span class="line">    <span class="comment">// 此时table中保存的是t和s的次数差值，如果table中元素全为0，说明t和s是字母异位词，每个字母使用次数相等。如果出现任何非零值，则不是。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(table[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="力扣-349">力扣 349</h2><p>  <a href="https://leetcode.cn/problems/intersection-of-two-arrays/" target="_blank" rel="noopener noreferrer">两个数组的交集</a><br>  这个题不适用数组作为哈希表进行解决，因为可能输入的数据量非常大，数组会增加存储开销。因此用 set 数据类型进行解决，set 和 map 一样，也是一类哈希表，不过只有一列数据。C++ 中可由下面定义：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set</span><span class="params">(vector&lt;<span class="type">int</span>&gt;.begin(), vector&lt;<span class="type">int</span>&gt;.end())</span></span>;</span><br><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">set</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">set.<span class="built_in">begin</span>();</span><br><span class="line">set.<span class="built_in">end</span>();</span><br><span class="line"><span class="comment">//插入数据并自动去重</span></span><br><span class="line">set.<span class="built_in">insert</span>(target);</span><br><span class="line"><span class="comment">//寻找目标数据（迭代器）</span></span><br><span class="line">set.<span class="built_in">find</span>(target);</span><br></pre></td></tr></tbody></table></figure><p>  这里先将  nums1 转换为 set 数据，然后查找 nums2 中的元素在 set 表中是否存在，如果存在就将结果保存下来，最后输出。这里用 set 还有一个好处就是会自动去重，所以无需处理结果中可能存在的重复元素。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 使用迭代器初始化set表</span></span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">table</span><span class="params">(nums<span class="number">1.</span>begin(), nums<span class="number">1.</span>end())</span></span>;</span><br><span class="line">    <span class="comment">// 遍历 nums2 中的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums2)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 迭代寻找 num 是否存在于表中</span></span><br><span class="line">        <span class="keyword">if</span>(table.<span class="built_in">find</span>(num) != table.<span class="built_in">end</span>())</span><br><span class="line">            <span class="comment">// 存在则保存结果（这里会实现去重）</span></span><br><span class="line">            res.<span class="built_in">insert</span>(num);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 使用迭代器的方式将 set 类型转换为 vector&lt;int&gt; 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  时间复杂度是 $\small {O (M + N)}$，$\small {N}$ 是遍历 nums2，$\small {M}$ 是最后 res 转换为 vector。空间复杂度是 $\small {O (N)}$。</p><h2 id="力扣-454">力扣 454</h2><p>  <a href="https://leetcode.cn/problems/4sum-ii/" target="_blank" rel="noopener noreferrer">四数相加 Ⅱ</a><br>  这个题目如果使用暴力解法，复杂度是 $\small {O (N^4)}$。注意到题目要求 nums1 [i] + nums2 [j] + nums3 [k] + nums4 [l] == 0，也就是 nums1 [i] + nums2 [j] == - nums3 [k] - nums4 [l]。那么可以两两一组，先遍历计算 nums1 和 nums2 元素的和，并建立 map 表（这里用 map 表是因为可以利用 value 统计相同元素出现的个数），然后再遍历寻找 nums3 和 nums4 元素的和（取相反数）是否出现在 map 表中，如果出现将对应 value 值相加，最终就能够返回元组个数。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 初始化table后table里面的value默认为0</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; table;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; a : nums1)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; b : nums2)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 这里有两层含义，如果a + b在table中有相同的元素，value++，如果没有，那么table 自动添加a + b的值，并value++</span></span><br><span class="line">            table[a + b]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; c : nums3)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; d : nums4)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> target = -(c + d);</span><br><span class="line">            <span class="keyword">if</span>(table.<span class="built_in">find</span>(target) != table.<span class="built_in">end</span>())</span><br><span class="line">                <span class="comment">// 这里意思是返回指定key下的value</span></span><br><span class="line">                count += table[target];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>  时间复杂度是 $\small {O\left (N^2 \right)}$，空间复杂度是 $\small {O\left (N^2 \right)}$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  哈希表就是在关键字和存储位置之间建立对应关系。也就是：&lt;/p&gt;
&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-src&quot; hidden=&quot;&quot;&gt;  flowchart LR
    A[&quot;关键字&quot;] --&amp;gt; B[&quot;存储地址</summary>
      
    
    
    
    <category term="力扣刷题" scheme="https://luotian.cyou/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="哈希表" scheme="https://luotian.cyou/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>XDU - STE 研究生生存手册</title>
    <link href="https://luotian.cyou/post/live-in-xdu.html"/>
    <id>https://luotian.cyou/post/live-in-xdu.html</id>
    <published>2025-07-07T14:25:35.000Z</published>
    <updated>2025-10-31T18:51:28.606Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong><font size="4" color="#13cfbe">前言：本文部分内容因专业原因并不通用，请注意甄别喵ᓚᘏᗢ</font></strong></p><h2 id="一、答案相关">一、答案相关</h2><ul><li><a href="https://www.luotian.cyou/post/Aca-Stan-Dis-Wri.html">西电雨课堂 - 学术规范与论文写作答案</a></li><li><a href="https://www.luotian.cyou/post/Sci-ethics-ethos.html">西电雨课堂 - 科学道德与学风答案</a></li><li><a href="https://luotian.cyou/post/Aca-Commu-Eng.html">西电雨课堂 - 学术交流英语答案</a></li></ul><h2 id="二、培养相关">二、培养相关</h2><h3 id="2-1-培养方案">2.1 培养方案</h3><p>  专业的培养方案每隔几年可能会变，不同学院、不同专业的培养方案也不一致，选课前建议详细查询本专业的培养方案。以 2025 级信息与通信工程的<a href="https://yjspt.xidian.edu.cn/gsapp/sys/pyfacxapp/*default/index.do?_yhz=20190703140744276&amp;v=4d3e876e-86d3-4ad4-a454-a38f9e98ba1d&amp;#/pyfacxlb/2025//04/001" target="_blank" rel="noopener noreferrer">培养方案</a>为例，计划总计学分为 30 分，其中包括必修课和选修课，每类课程要求最低学分和细则如下。</p><ol><li>政治理论课 3 学分 = 自然辩证法概论（1）+ 新时代中国特色社会主义理论与实践（2）</li><li>英语公共课 2 学分 = 学术交流英语（一）（1）+ 四选一（1）</li><li>专业核心课 9 学分（需凑分，即其中一类需选两门）<br> A. 数学课 3 学分 = 至少 1 门<br> B. 专业核心课 3 学分 = 至少 1 门</li><li>专业课 4 学分（需凑分）</li><li>任选课 0 学分 = 凑学分用，且可以选方案外课程，优先选网课</li><li>必修环节 4 学分 = 社会实践（1）+ 学术活动（1）+ 学术实训（2）</li><li>综合素养课 1 学分 = 多选一，优先选网课</li><li>公共限选课 2.5 学分 = 体育（1）+ 学术规范与论文写作（1）+ 研究生心理健康教育（0.5）</li></ol><p>  其中在每年秋季研究生入学时会进行英语能力等级认定，并采用分级教学，满足其中之一可申请英语课程免修：</p><blockquote><p>a. 四级 ≥ <strong>550</strong> or 六级 ≥ <strong>460</strong><br>b. 托福 IBT ≥ <strong>90</strong><br>c. 雅思 ≥ <strong>6.0</strong><br>d. 专业四级<strong>合格</strong><br>e. 入学英语成绩 ≥ <strong>73</strong></p></blockquote><h3 id="2-2-选课">2.2 选课</h3><p>  一定要先制定培养计划，然后才能进行选课。每个实验室都会有前辈的选课攻略，请优先进行参阅。由于选课网站登录信息存在刷新机制，一段时间后会强制退出登录，选课过程中建议准备多个不同种类浏览器。优先选（抢）思政、英语、体育、数学课，其中思政和英语的优先级最高，专业课等其他课程视情况而定，网课最后选（因为课程容量非常大，随时都有名额）。<br> <a href="https://yjsxk.xidian.edu.cn/yjsxkapp/sys/xsxkapp/index.html" target="_blank" rel="noopener noreferrer">点击进入研究生选课网址</a><br>  <strong>3 + X 培养计划</strong><br>  大四第二学期前，如果报名了西电研究生春季学期的<a href="https://ste.xidian.edu.cn/info/1212/2307.htm" target="_blank" rel="noopener noreferrer">3 + X 培养计划</a>（细则详见各院通知），会在这一学期选两门课程提前学习，选课方法同上，需先完成培养计划制定，再完成选课及选班操作。<br>  这个 3 + X 培养计划就是提前一学期上课，选择与否看个人意愿。主要看上课时间是否合适、上课地点是否方便（很多课在北校区）、是否是培养方案内的课程。至于期末是考试还是考察看个人选择，期末考试一般在 7 月初左右。就算没选，有些课迟早还是要学的，如果考试不及格开学重修过了就行，不要有压力。如果选择了网课，记得在西电研究生院官网上查看网课的<a href="https://gr.xidian.edu.cn/info/1073/15334.htm" target="_blank" rel="noopener noreferrer">开课通知</a>，并按照要求注册学习。学习平台为<a href="https://xidianyjs.yuketang.cn/" target="_blank" rel="noopener noreferrer">雨课堂</a>。</p><h3 id="2-3-期末">2.3 期末</h3><h2 id="三、生活相关">三、生活相关</h2><h3 id="3-1-研究生活">3.1 研究生活</h3><ol><li>研究生阶段会办理<strong>中国银行</strong>的借记卡，涉及研究生补助、奖学金发放，一般会在大四学期末通知：<a href="https://ygb.xidian.edu.cn/info/1036/5313.htm" target="_blank" rel="noopener noreferrer">2025 级研究生新生银行卡办理通知（一）</a></li><li>入学前暑假在 7 月 14 日发布了<a href="https://xdyx.xidian.edu.cn/info/1005/2494.htm" target="_blank" rel="noopener noreferrer">2025 级研究生报到须知</a>，附件：<a href="https://blog-comment-luotian.oss-cn-chengdu.aliyuncs.com/2025%E7%BA%A7%E7%A0%94%E7%A9%B6%E7%94%9F%E6%8A%A5%E5%88%B0%E9%A1%BB%E7%9F%A5.pdf" target="_blank" rel="noopener noreferrer">2025 级研究生报到须知.pdf</a>。我这里做了新生报到的时间节点供参考。25 级现场报到时间是<strong> 2025 年 8 月 30 日 8:00 - 20:00</strong>，通院地点在<strong>北校区主楼二楼中厅</strong>。报到流程如下：<br>  缴费确认 → 学历学位证书检查 → 校园一卡通领取 → 入学体检和医保办理 → 入住宿舍<br><img src="https://blog-comment-luotian.oss-cn-chengdu.aliyuncs.com/yjsrxlc.jpg" alt="西电研究生入学一图流"></li><li>入学前暑假在 8 月 10 日可以查到住宿信息了，具体在企业号 → 移动门户 → 公寓管理（注意需要以研究生身份注册或绑定企业号）。</li><li>通院 25 级硕士研究生在 #97 楼（女）和 #98 楼（男），位于学校的西南门附近，离驿站很近。通院的宿舍按学号分，并非按导师组。宿舍户型是上床下桌 4 人间，有个封闭小阳台可以洗漱和晾衣物，有空调暖气和独立卫生间，晚上不断电。宿舍楼（老旧宿舍楼除外）每一层都有专门洗澡、洗衣、吹头发的地方。洗澡的地方是由 4 个小单间构成，手机下载<strong>云达人</strong> APP，扫描淋浴间内的二维码即可使用。洗衣间有 4 台滚筒洗衣机和一个直饮水机，直饮水机也是使用云达人 APP 进行扫码使用。</li></ol><h3 id="3-2-吃喝玩乐">3.2 吃喝玩乐</h3><ol><li>北校区附近有家李姑婆自助牛肉火锅着实不错。北校区离小寨之类的很近，有时间可以去走走逛逛。</li><li>学校旁边白沙路有家芳芳餐厅，20 多年的老店，里面中餐味道很不错，适合朋友之间小撮一顿。</li></ol><h2 id="四、好物推荐（无恰饭）">四、好物推荐（无恰饭）</h2><h3 id="4-1-好用的软件">4.1 好用的软件</h3><ul><li><p><a href="https://legacy.superbart.top/traintime_pda/" target="_blank" rel="noopener noreferrer">traintime_pda</a><br>  开源的西电学生信息查询软件，支持查看本科生和研究生的课程信息、成绩信息、考试信息等等（iOS 友好）。</p></li><li><p><a href="https://www.amyxun.com/" target="_blank" rel="noopener noreferrer">AXmath</a><br>  一款公式编辑器，36rmb，支持面板编辑公式和 Latex 语法，新版本还支持公式截图识别，个人评价物超所值，有很多快捷键，无论是手打还是截图识别，是用过所有公式编辑器里体验最舒服的一个。</p></li><li><p><a href="https://www.voidtools.com/zh-cn/" target="_blank" rel="noopener noreferrer">Everything</a><br>  小天才智能搜索，哪里搜不到搜哪里。一款非常好用的文件检索软件，免费，能够快速找到所有磁盘中包含搜索内容的文件或文件夹名称。找东西非常好用。</p></li><li><p><a href="http://www.ffhome.com/works/ffrenamepro/1.html" target="_blank" rel="noopener noreferrer">菲菲更名宝贝 - FFRename</a><br>  一键批量文件重命名工具软件，免费，支持各种复杂的命名规则，只有你想不到，没有它做不到。</p></li></ul><h3 id="4-2-好用的网站">4.2 好用的网站</h3><ul><li><a href="https://www.luotian.cyou/tools/ocrlatex/">洛天的小窝 - 图片公式识别</a><br>  使用 Latex 识别 API 和开源代码集成的图片识别公式功能。每天有 500-1000 次的免费调用额度。</li><li><a href="https://www.autodl.com/home" target="_blank" rel="noopener noreferrer">AutoDL</a><br>  便宜好用的算力租赁平台，我的本科毕设就用的这个。</li><li><a href="https://survivexdu.github.io/SurviveXDU/" target="_blank" rel="noopener noreferrer">西安电子科技大学生存手册</a><br>  老学长的圣遗物，大部分是有关南校区和本科生的内容。不过有很多东西可以参考借鉴，比如 “提问的艺术”。</li><li><a href="https://netron.app/" target="_blank" rel="noopener noreferrer">Netron</a><br>  一个可以读取并直观展示你的神经网络模型内部结构的应用。</li></ul><h2 id="五、规则怪谈">五、规则怪谈</h2><h2 id="六、碎碎念">六、碎碎念</h2><ol><li>不要自己太压力自己，该摸鱼的时候得摸鱼。</li><li>研究生入学前的暑假应该是最后一个无忧无虑的暑假了，玩也好、忙也罢，好好珍惜就行。</li></ol><p>  读者看到这里，我也简要聊聊撰写这篇博客的缘由及碎碎念吧。我的最主要缘由还是想打破信息差，为了某些重要但不紧急的信息浪费太多时间，私以为是不必要也不应该的（当中不乏很多客观因素的影响），不如省下时间用在放松休息或自我提升的地方，我觉得应该有这样一个信息交流的平台，无论是以什么样的方式呈现（当然已经有很多人正在做类似的事情，奉上感恩与赞美之心❤）。此外，用记录对抗时间带来的遗忘，无论是摄影、博客或者是书信，这些都是充满意义的事情。或许若干年后成为了所谓的 “老学长”，这个网站也能给学弟学妹们带来些帮助吧。要是喜欢我的文章或者觉得有帮助，还请多多支持转发，后面会持续更新有价值的博客内容 (●’◡’●)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  &lt;strong&gt;&lt;font size=&quot;4&quot; color=&quot;#13cfbe&quot;&gt;前言：本文部分内容因专业原因并不通用，请注意甄别喵ᓚᘏᗢ&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、答案相关&quot;&gt;一、答案相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo 配置 mermaid—butterfly 主题</title>
    <link href="https://luotian.cyou/post/mermaid4hexo.html"/>
    <id>https://luotian.cyou/post/mermaid4hexo.html</id>
    <published>2025-07-06T13:14:06.000Z</published>
    <updated>2025-08-14T06:07:39.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、插件安装">一、插件安装</h2><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams</span><br></pre></td></tr></tbody></table></figure><h2 id="二、修改配置文件">二、修改配置文件</h2><h3 id="2-1-博客配置：-font-color-FF5733-config-yml-font">2.1 博客配置：<font color="#FF5733">_config.yml</font></h3><p>  <code>_config.yml</code>在根目录。</p><ol><li>在末尾添加以下内容：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># mermaid chart</span><br><span class="line">mermaid: # mermaid url https://github.com/knsv/mermaid  </span><br><span class="line">  enable: true  # default true  </span><br><span class="line">  version: "7.1.2" # default v7.1.2  </span><br><span class="line">  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js  </span><br><span class="line">    #startOnload: true  // default true</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>搜索<code>external_link</code>字段并改为<code>false</code></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">external_link:</span><br><span class="line">  enable: false # Open external links in new tab</span><br><span class="line">  field: site # Apply to the whole site</span><br><span class="line">  exclude: ''</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-主题配置：-font-color-FF5733-config-butterfly-yml-font">2.2 主题配置：<font color="#FF5733">_config.butterfly.yml</font></h3><p>  <code>_config.butterfly.yml</code>是主题配置文件，通常在 themes\butterfly\。搜索找到<code>mermaid</code>字段，并启用 mermaid：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mermaid:</span><br><span class="line">  enable: true</span><br><span class="line">  # built-in themes: default/forest/dark/neutral</span><br><span class="line">  theme:</span><br><span class="line">    light: default</span><br><span class="line">    dark: dark</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-设置流程图背景为透明（可选）">2.3 设置流程图背景为透明（可选）</h3><p>  这里是因为 mermaid 会默认给流程图添加灰色背景，而设置成透明背景会显得比较美观。</p><ol><li>找到 themes\butterfly\source\css\ 下的<code>custom.css</code>文件，若没有请新建一个，在末尾添加以下内容（<code>transparent</code>即为 “透明”，后续想修改背景颜色可以直接修改<code>background</code>字段）：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/*mermaid*/</span><br><span class="line">.mermaid {</span><br><span class="line">  background: transparent!important;</span><br><span class="line">  opacity: 0.9;</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>在_config.butterfly.yml 中搜索<code>inject</code>字段，在<code>head</code>中添加以下内容：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">    - &lt;link rel="stylesheet" href="/css/custom.css"&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="三、编写mermaid">三、编写 mermaid</h2><p>  在文章中插入 mermaid 块即可，也就是：</p><p><img src="/img/blogs/250706_0201.png" alt="mermaid块"></p><p>  渲染的得到的流程图如下：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden="">  graph TD;    A--&gt;B;    A--&gt;C;    B--&gt;D;    C--&gt;D;    classDef default stroke-width:3px,font-size:25px,fill:transparent  </pre></div><h2 id="四、参考与友链">四、参考与友链</h2><ul><li><a href="https://weixiansheng1.github.io/2023/10/02/hexo%20%E5%8A%A0%E5%85%A5mermaid/index.html" target="_blank" rel="noopener noreferrer">hexo 加入 mermaid（基于 butterfly 主题）</a></li><li><a href="https://mermaid.nodejs.cn/" target="_blank" rel="noopener noreferrer">mermaid 官方中文文档</a></li><li><a href="https://www.mermaidchart.com/app/projects" target="_blank" rel="noopener noreferrer">mermaid 在线编辑器</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、插件安装&quot;&gt;一、插件安装&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-</summary>
      
    
    
    
    <category term="hexo博客" scheme="https://luotian.cyou/categories/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="https://luotian.cyou/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java 技术栈学习路径</title>
    <link href="https://luotian.cyou/post/javaroad.html"/>
    <id>https://luotian.cyou/post/javaroad.html</id>
    <published>2025-07-06T09:20:23.000Z</published>
    <updated>2025-07-09T17:54:57.041Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6f68c65b6f1fb2f3110a452dab5f8556c987bc096088fb5cca8b3ce003849211">2b2c1cd4235530843f47c1ca432ab0464415c7ebb125acdb43845259f6c8408a3fb594835b18f8c05d581c35402fb0e9f3434ba2ba71ce51e307fdb8b8ed287502fa3f28194b4e06a3e6dc2621743c86a15128b38e41deed1b9f49f9aef2ff77c1721daf6df9cf0a73adc554f8a13339cf7cbeb2b51e78239e19f1373b5526f466252342efac460ca2c8bbeaa1302ddf3b51b187c1552bebb05675cd1fd875e2869b445ce9a64d449b2120466449fdb55e2886a53a2cb9b8e40ea1e10abcc645a6a92da4faa2fc5c5d10cc4c0cf34f4eeb980706e175ba3f30c2dc992c68451dd12e64d269a5d911e1601688e3795e6e85aa8354da7408533f5ead249c90320760bb27b3d88e4666c02f42c55ea6048011671ea0fc8c08b952198fea264ab112c8531d23fcc7ff6750694fc87074465a4fed6822e5c9fe6221b2490af11e704803dfb9870c875c7a3b885589cfacf873b8e20106265e11c98362b72fc852e8c03be4ee317c8bfd524852bd8cf8dcd05f66edfa2a8c640b29f825acbbafd5370c67ec99acdd742ab04e051fdc922e38c93044f04c178c99c58bbe05e929b59ba27768d3ec7419e4e1968f9aafa3ff9dae7558666fb91e393892a05681eff6488fda014c6c079e7ee9b6356cf2312cf057ad7fc655074270b5d6aab8276f5cd32c73965859f817d727d7d2a9070c647b738e5cd619018477b8d441999d62ba6e4c74d95dafd5c648a809337da80bccd871145950dfea7f16d5d1fc98a349b744287b9fd92a1c553be16ea4593c4dab51ed41d70057d3eb95405eddfd74993cce96220a8a09befc788138b6d42af37f77471e29a7f75a1b905427968a9ba0e7a87cae50457126e64944fdcb3340ec75059aa0e3ede3acb950bfac677139b407736f3aba398b58646e6d1c9c836b8adb463401bf4ddff13f542cc7a461f4e243838b61da5867d15de1cefc80cd51a1366f6394cd720e9e02735da1adbe35a11b68fd8870c14c9b35d78ede26078a8c7e74fce9f0a279568a7d53f837fca07ec4b2e297c4a35b338d9e22b00b652716b405a418a49565f94b63ee2d4b7131f90b919bea81fb6e3f220433d17317ed912bbe3b8f9b54061a0406370690cd75b831c7a233a7f4202cd5012797fe092deb3f6b7b4bf79e9a73724c0373dff034de720da3d4724626498b86eaea45dae61267098f4412274d41ca79bcec24c02996a8daedb32683f468469dae45ee8f106e417cb686db243a0e906c6b55504f1fb1a6ad5c7996f4b73bc80a63867d5f3d4fce5bfbb168ab2c221e4b8a57e775e323c61ec10b84e39e2be3f0045df3abfc16389939eb079b341dbd7a9a069a01dc66996207047445470d5d681874a143563e6675c4a3fbbede845fba2adc561f85b6cc89a698961016f9cd5c4dcf7d12b4b26c3aef33c16e9cc8bab46dbe18ca8cb5da587538a1013fd03a3a072e6827a28159f674e4e0c0d60e49ead09cdc4bb88bc7e77bf9a2844df82750d7d641ec15ce0d90b28fbfb2834a071192af55f2cadfe9540f79689aaad60c14edfb44ec72b7690d9cc654aaf3e1e79b53b447f12ae5e1f6bc256910814dc96bafdadccded7cbd277a5b9f5098c159b5feb2a63f285a4d353bf90afbbe495c1691770cc6be11992427adb7d191a61d21309f66ca4a7f764c4217275f38747340f733873a3913442b8a266e27f954e1b8abadf3cfa3f96d7941bacb6dace315d18f3321af4a49ead3bd36bca3671b2fbdac15d14accbe6b91e4d96c288c6e555b39f6442696a08139ec09251bb3debf6268afb4171078984062236b34858bf7057f21c645f15e07b66d6c834daeab473fc3ed18788c34caee09d1f411cc60cf3cf0930fc6dca9b3162137326b16b34264db7879458d37c0d63aadb960ce5ba19b0d6beb80afe4a3df74b88b4d63e5cb9fb44766c16c9a88e31cffa797cd2837f26e91befca5bc1c460960c2abd3b1bc8af0338cc19035e3ea6c4624ac9012950da0371127f01f737b201355b962265c62cdbd35fbea9bf08154cf9c962b2cafecc5305f28de489e59a2840ec7020458a5b2680c77953057075d6b378e3d5af2eb62a7561be42b4eb5091b6cffdb3d347384a05f0edeab5d71aaacbe79d06051c8e7eb5174831d788f09181090b35cf1568b34ba6c1d12c417ab6fe139cebbb21b1a15eac2232d9b876c4dc7804bf4459cf2fb39123142a0a8b6ec745b0807609fe74d4b0ada63f7cdb3bacd45f53913e1a630cd15094c95ccceb5f868e37d46ed86cec3c465501df58ae439a3cb603a714d9856971ad06c1556e01348913735ba0429d2f20dc2a21760f4e73020c5e0ee19bdc7be4a05996101af34af3f64058406eca53ffea7e0f9806e4752719fb5d2c773cf9bbb4c001c2c5c8e22d54afc0f76e9e2be3469059a1d4d25e8f5cd379c100bfbdf317491814daeb7b72b55d46783e84e73e4ac5f523e7055ddeaa48545a49a08fff49be4e2bb9d5d96cb51608e5417f10b5d00c15b84e1705b417db72d241cdcf9258dda44c6ce799442d9b59a6bbe21de5cbcae00ce3a5fdcf8bc3f795a1db55928ed900ec82edc310a57a17fbfed38fc1fd8a0763da0178d202d26e40a691ed136c29b2cf5ad4c56a0f44cae2ecb69bc0d047feffca9f16df97d4ae69f62b7ddc9f8f7ea3c607fbadcf6478e03a127874035140f409ea59e9d52e8c1d061cf8fcb2e455d2be441fea8e71f17597fc33992af362287c42222d2b44f54ed283ff2b5e8c1c886b323fa9ff10253b6ca3205f4c3ee0ee6b83222a6d443cdf47b7c54ec900fdecb6ddbee8bcad227611226e8084316bcd8ca6ff5cea0ba33dd3d16b88d7574619b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="Java编程" scheme="https://luotian.cyou/categories/Java%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://luotian.cyou/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>西电雨课堂 - 学术规范与论文写作答案</title>
    <link href="https://luotian.cyou/post/Aca-Stan-Dis-Wri.html"/>
    <id>https://luotian.cyou/post/Aca-Stan-Dis-Wri.html</id>
    <published>2025-06-27T03:10:53.000Z</published>
    <updated>2025-08-15T14:03:27.100Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font size="4" color="00b9ff">前言：章节答案由我自己整理，期末考试答案引用自【参考博客】</font></strong><br><strong><font size="3" color="#28b463">考试成绩已出，45 道题错了 4 道，貌似期末考试答案有些错误在里面。试卷不能查看我无法进行答案更正，不过错四道也没什么影响，随便过 (・̀ ω・́) y</font></strong></p><h2 id="center-第一章-center"><center>第一章</center></h2><h3 id="1-1-章节习题">1.1 章节习题</h3><ol><li>根据本周所讲内容，对于论文标题的撰写，以下描述正确的是<br>A、标题应尽量精炼简洁<br>B、标题需注意保护知识产权<br>C、标题应反映核心技术</li><li>什么样的论文能被称为优秀的论文<br>A、论文能开辟一个新的方向<br>B、论文能获得学术界重视，获得足够的引用<br>C、论文有一定的研究价值<br>D、论文有一定的创新意义</li><li>根据本周所讲内容，对于论文摘要的写，以下描述正确的是<br>A、摘要应覆盖文章的亮点及效果<br>B、摘要是标题的扩充<br>D、摘要应覆盖文章的出发点</li><li>关于论文写作，以下说法正确的是<br>A、写论文时应换位思考，从读者的角度出发<br>B、写论文时可以描述分析思路，从而扩充论文长度<br>C、一篇好的论文从初稿到终稿应至少改 10 遍<br>D、论文的语言表达应尽量简洁</li><li>根据本周所讲内容，关于总结和参考文献说法正确的是<br>A、以完成了所有工作的口气来撰写<br>B、可以提出未来研究方向<br>C、参考文献需要包括刊物名称、卷号、年份<br>D、总结需注意与摘要的区别</li></ol><h3 id="1-2-论文写作语法练习">1.2 论文写作语法练习</h3><ol><li>Compared to the existing techniques, the proposed one requires less variables to train images, so makes the learning procedure much easier.<br>×</li><li>If it is set to $\small{\text{NULL}}$, means the instance is the first simple pattern of its corresponding regex.<br>×</li><li>Hence, the input characters are mapped according to Table 2.5, which results the buffer shown in Figure 2.7, where the left array represents the disjoint character set and the right boxes are buffer nodes including string position.<br>×</li><li>The next step is to deeply analyzed malicious time intervals to extract attack flows.<br>×</li><li>Similarly, the upper bound $\small{\text{A&lt;B}}$ for the number of collected candidate vectors also holds as well.<br>×</li><li>The channel vectors are normalized by a global normalization value A that is the largest absolute value in the whole dataset, and can be expressed as $\small{\text{A=B+C}}$.<br>×</li><li>With the reflecting elements, an RIS can constructively combine the reflected signals to achieve a high level of energy, and further reconstruct the radio scattering environment into an intelligent one.<br>×</li><li>The complexity of ESD by means of the number of visited nodes is upper bounded by $\small{\text{n&lt;A*B}}$.<br>×</li><li>In this paper, a novel framework with respect to sphere decoding is established by the proposed ESD algorithm.<br>×</li><li>To start with, according to Lemma 2, the number of saved candidate nodes at each searching layer is upper bounded by the summation of searching sizes at the previous layer.<br>×</li><li>Similarly, the same result about the choice of j can also be derived through ESD.<br>×</li></ol><h2 id="center-第二章-center"><center>第二章</center></h2><ol><li>下面哪个选项，最符合本课程所介绍的写好科研论文主要步的顺序<br>a、找到值得研究的问题<br>b、转变学习观念和学习方式<br>c、发表文章<br>d、逐步加深对学术研究的认识<br>e、写出较高水平的学术文章<br>f、结合专业，学会方法<br>C、bfdaec</li><li>本讲授课教师认为，研究生阶段，应该转变为以下哪种学习方式<br>B、创造性的学习方式</li><li>以下哪种说法，不符合本讲授课教师的观点<br>D、研究生不应该模仿</li><li>本讲授课教师认为，评判学术论文质量的最主要标准，包括以下哪些<br>A、学术论文的形式标准<br>C、论文的创新性，主要体现在新观点、新材料、新方法三个方面</li><li>本讲授课教师认为，学会做科研最关键的一步是<br>C、找到值得研究的问题</li></ol><h2 id="center-第三章-center"><center>第三章</center></h2><ol><li>电子期刊订阅的方式有哪些<br>A、RSS 源订阅<br>B、邮箱订阅</li><li>文献管理的专业软件有哪些<br>B、endnote<br>D、Note express<br>E、Zotero</li><li>你如何选择投稿的期刊<br>A、参考你自己经常读的文献所在的期刊<br>C、参考已有成功经验的同学都投了哪些期刊<br>D、咨询导师的意见</li><li>文章经过同行评议后，审稿人的意见比较负面，但是你觉得有可能是审稿人没有理解你的工作，你会怎么做<br>C、委婉回复，将自己文章的创新点说清楚</li></ol><h2 id="center-第四章-center"><center>第四章</center></h2><ol><li>You are writing the Results section of your article. Which of the following guidelines should you follow?<br>B、Use sub-headings to keep results of the same type together<br>D、Include illustrations and figures<br>E、Use scale markers for every photograph and image</li><li>You are writing the References section of your article. Which of the following guidelines should you follow?<br>D、Ensure that you fully understand the material you are referencing</li><li>Who is responsible for checking the language quality used in a research paper?<br>B、Author</li><li>You are working on your first scientific paper. Which of the following is an acceptable sentence structure for your article?<br>C、We found that the study subjects responded well to compound X in repeated tests. We also found that the response to compound Y was not consistent.</li><li>You are sending a paper to a publisher. Which of the following sentences represent good grammar for your manuscript?<br>B、The study subject’s ECG patten was within normal range.</li></ol><h2 id="center-第五章-center"><center>第五章</center></h2><ol><li>You are a researcher wanting to publish a study undertaken in human beings. Do you need to provide detail about which organization gave ethical approval and how consent was obtained?<br>A、Yes</li><li>You are working on a study and the results are not coming out the way you want them to. You just cannot confirm the hypothesis no matter how many times you rerun the tests. You’re the one conducting the research and the only one managing the data analysis. You want to successfully resolve this. What are your options?<br>C、You consult with your supervisor and/or lab team to troubleshoot, even if it means going back to the drawing board. There are no short cuts in science.</li><li>You are preparing a paper that involves a complex concept but you’re having difficulty putting into words precisely how this concept works. You see an excellent explanation in another published paper. ls it okay to use this explanation word for word in your paper without referring to the other paper?<br>B、No</li><li>Let’s say Cell accepts your paper for publication. ls it always okay to submit aversion of that paper in a language other than English to a journal in a different country or does that count as duplicate submission?<br>B、NO, it’s not okay. It counts as duplicate submission.</li><li>What situation might be considered a conflict of interest? A researcher who (select all that apply)<br>D、All of the above.</li></ol><h2 id="center-期末考试-center"><center>期末考试</center></h2><ol><li>引用尽量避免非原创的第二手资料<br>√</li><li>写文章的顺序应该和读文章一样<br>×</li><li>论文翻译后再出版，有些情况下是可以的<br>√</li><li>讨论部分需要与前任结果进行比较并重视不一致的部分<br>√</li><li>投稿期刊应该认真根据 guide for author 修改文章的格式<br>√</li><li>方法类期刊专门用于发表各领域有价值的方法<br>√</li><li>研究过程可以间断<br>×</li><li>审稿人会有一定的收入作为报酬<br>×</li><li>论文的图片中可以使用当地语言<br>×</li><li>论文的形式都是一样的，对不同的期刊直接投稿就可以了<br>×</li><li>可以将同一项研究分成几篇论文发表<br>×</li><li>引用中被省略号连接的一部分<br>√</li><li>期刊的影响因子越高期刊的声望越高<br>×</li><li>出版商或期刊编辑会帮助作者修改文章语言<br>×</li><li>论文写作一定要具备新观点、新材料、新方法三要素<br>×</li><li>学术道德的责任只有作者<br>×</li><li>确定研究主题主要考虑研究的创新性就可以了<br>×</li><li>SCI 论文写作中由于示意图极大增加了可读性，所以示意图是必选项<br>√</li><li>论文被拒后直接转投是可以接受的<br>×</li><li>SCI 论文写作步骤依次是：产生想法 - 做实验数据处理 - 写文章 - 投稿 - 返修文章 - 接收<br>√</li><li>自我引用就不用标注出处了<br>×</li><li>文献阅读一般可以分为精读和泛读<br>√</li><li>标题里除了公认的缩写如 DNA 之外，一般不应使用缩写<br>√</li><li>DNA 这样的用词在文章中是没问题的<br>√</li><li>摘要在索引工具中可以免费获得<br>√</li><li>Cover letter 的重点是<br>A、强调创新性</li><li>撰写论文的标题应<br>A、尽量精炼简洁</li><li>论文的讨论部分应<br>A、以上都不正确</li><li>精读一篇论文至少要几遍以上<br>A、5</li><li>选择期刊最重要的是<br>A、期刊的声望</li><li>如何选择自己的科研领域<br>A、兴趣</li><li>选择导师的最重要标准是<br>A、适合</li><li>抄袭、剽窃侵吞他人的研究成果属于<br>A、学术不端</li><li>学术论文选题时要经过<br>A、以上都正确</li><li>论文的摘要部分不必须包括<br>A、方法的详细介绍</li><li>学术论文最高层次的创新是<br>A、原创</li><li>《读书的方法》作者<br>A、张五常</li><li>同行评议最早产生于<br>A、17 世纪中叶</li><li>论文写作建议顺序<br>A、摘要 - 引言 - 实验过程 - 结果讨论 - 结论</li><li>“从事实出发，而非从原则出发” 的作者<br>A、王小盾</li><li>投稿论文前应考虑的因素不包括<br>A、文章是否具有商业价值</li><li>有 ()% 投稿文章被拒是很正常的<br>A、70-80</li><li>最常见的论文形式是<br>A、研究型论文</li><li>学术不端行为最常见的是<br>A、剽窃</li><li>方法部分一般使用什么语态<br>A、被动语态</li><li>一般文章再发表之前一般会经历<br>A、1-3 轮返修</li><li>期刊选择的考虑要素不包括<br>A、与编辑相熟</li><li>关键词的选取应该避免<br>A、使用意义太广泛的词语</li><li>研究生阶段最重要的是<br>A、转变学习观念和学习方式</li><li>《研究生学术入门手册》提到给硕士生<br>A、方法</li><li>描述已知的事实和假设时应该用什么时态<br>A、现在时</li><li>描述进行过的实验及其结果时应使用什么时态<br>A、过去时</li><li>文献一般重点引用哪些<br>A、重要文献<br>B、最新文献</li><li>在数字时代论文写作中变得更为重要的部分是<br>A、关键字<br>B、摘要</li><li>论文致谢部分一般包括<br>A、提供材料者<br>B、导师<br>C、提供参考建议的同行<br>D、资助者</li><li>发表论文应注意<br>A、不准由第三方代投论文<br>B、不准由第三方代写论文<br>C、不准由第三方对论文内容进行修改，包括论文润色<br>D、不准提供虚假同行评审人信息</li><li>论文中最应该避免的语言错误是<br>A、拼写错误</li><li>什么情况下可以发表你的成果<br>A、研究有原创性<br>B、对某领域有独特领悟的总结<br>C、对既有研究有提升</li><li>研究生如何做学术<br>A、要有研究兴趣<br>B、要积累论文<br>C、要学好数学<br>D、要有高质量成果目标</li><li>为找到值得研究的问题，可以<br>A、挖掘读书中发现的问题<br>B、关注个研究生论坛及会议征稿<br>C、留意课程学习内容<br>D、可以从学术热点问题出发</li><li>找到值得研究的问题的方法包括<br>A、读书中发现问题<br>B、在课程学习过程中找<br>C、写综述<br>D、研究生论坛及学术会议征稿</li><li>规范严谨的英文写作包括<br>A、逻辑严谨<br>B、润色文章<br>C、语法<br>D、简洁地表达</li><li>研究生读书计划应包括<br>A、研究方向读书计划<br>B、专业读书计划<br>C、学位论文读书计划</li><li>作者的责任包括<br>A、原创性<br>B、数据真实<br>C、声明利益冲突<br>D、避免一稿多投</li><li>下列文献阅读的正确行为是<br>A、摘要要读，前沿最后一段要读<br>B、实验部分有新方法才读</li><li>评价学术论文原创的标准有提出了<br>A、独自的理论系统<br>B、独创的理论方法<br>C、独有的理论概念<br>D、独特的理论观点</li><li>世界上第一本学术期刊创建的意义包括<br>A、明确了学术期刊的四大角色<br>B、明确了学术出版物对于学术社区的关键作用</li><li>什么样的论文需要精读<br>A、经典<br>B、引用高<br>C、开创性</li><li>学术论文与学术研究的关系是<br>A、一定程度上，如何写论文就是如何搞研究<br>B、学术论文是对研究过程的书面记录<br>C、没有研究就没有学术论文</li><li>学术论文的创新主要体现在<br>A、新资料<br>B、新观点<br>C、新方法</li><li>回复审稿人意见，应<br>A、感谢编辑和审稿人帮助论文水平提高</li><li>学术不端行为包括<br>A、剽窃<br>B、伪造数据<br>C、篡改数据</li><li>为了更好的做科研，应该<br>A、付出大量的时间<br>B、进行充分全面的文献读研<br>C、经常与同行进行交流<br>D、选择一个合适自己的导师</li><li>工科论文写作的基本能力要素是<br>A、语言<br>B、数学<br>C、逻辑</li><li>下列哪些情况将会被退稿<br>A、引用比较新版本的经典著作<br>B、引用经典名著做略有错别字<br>C、用教科书或字典的材料作为证据</li><li>如何同期刊打交道<br>A、善于交流<br>B、善于推荐自己</li><li>研究生阶段学习和科研结合的好处<br>A、节约时间<br>B、可以得到老师的真正指导<br>C、积累写作经验</li><li>下面注释格式正确的有<br>A、中文期刊: 作者/篇名/期刊名/年期<br>B、中文古籍: 原作者/书名/部类名/卷次或篇名/版本</li><li>和学术期刊打交道的最大好处是<br>A、编辑部提出的技术方面的建议<br>B、编辑部聘请的审稿人的专业意见</li><li>论文写作前的积累包括哪些<br>A、实验细节<br>B、专业知识<br>C、Idea<br>D、讲座</li><li>什么叫精读了一篇论文<br>A、复现所有仿真<br>B、自己完成所有推导<br>C、至少读 5 遍以上</li></ol><h2 id="参考博客">参考博客</h2><ul><li><p><a href="https://blog.csdn.net/weixin_51339377/article/details/144206681" target="_blank" rel="noopener noreferrer">2024 - 雨课堂《如何写好科研论文》期末网课答案分享</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/531058734" target="_blank" rel="noopener noreferrer">2022《如何写好科研论文》课后习题</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;font size=&quot;4&quot; color=&quot;00b9ff&quot;&gt;前言：章节答案由我自己整理，期末考试答案引用自【参考博客】&lt;/font&gt;&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;&lt;font size=&quot;3&quot; color=&quot;#28b463&quot;&gt;考试成绩已出，45 </summary>
      
    
    
    
    <category term="课程答案" scheme="https://luotian.cyou/categories/%E8%AF%BE%E7%A8%8B%E7%AD%94%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>西电雨课堂 - 科学道德与学风答案</title>
    <link href="https://luotian.cyou/post/Sci-ethics-ethos.html"/>
    <id>https://luotian.cyou/post/Sci-ethics-ethos.html</id>
    <published>2025-06-26T17:47:46.000Z</published>
    <updated>2025-08-15T14:04:09.876Z</updated>
    
    <content type="html"><![CDATA[<p><strong><font size="4" color="00b9ff">前言：期末考试从章节练习题中选取，不会单独列出。所有题目由我自行整理。</font></strong><br><strong><font size="3" color="#28b463">考试成绩已出，全对，可放心食用😇</font></strong></p><h2 id="center-第一章-center"><center>第一章</center></h2><ol><li>1956 年，谁撰写的《工程控制论》获国家科学一等奖<br>A、钱学森</li><li>中国在什么时间成功爆炸第一颗原子弹<br>A、1964 年 10 月 16 日</li><li>中国在什么时间成功爆炸了氢弹<br>A、1967 年 6 月 17 日</li><li>1999 年国庆 50 周年前夕，中共中央、国务院、中央军委授予多少名科技工作者以每由 515 克纯金制成的 “两弹一星功勋奖章”<br>C、23 名</li><li>“科学没有国界，科学家却是有祖国的” 是谁的名句<br>C、钱三强</li><li>在五、六十年代的中国，科学界素有 “三钱” 之称谓<br>A、钱学森<br>B、钱三强<br>C、钱伟长</li><li>王平主编的《微波传播》一书在哪一年初版<br>B、1977</li></ol><h2 id="center-第二章-center"><center>第二章</center></h2><ol><li>《堆垒素数论》的作者是<br>B、华罗庚</li><li>获得中国第一个国家特等发明奖的科学家是<br>B、袁隆平</li><li>从 50 年代后期至 60 年代，李四光率领的勘探部门相继找到了哪些油田<br>A、大庆油田<br>B、大港油田<br>C、胜利油田<br>D、华北油田</li><li>居里夫人首次获得诺贝尔奖的时间是<br>B、1903</li><li>居里夫人获得过几次诺贝尔奖<br>B、2 次</li><li>居里夫人分别获得了哪个类别的诺贝尔奖<br>A、化学奖<br>B、物理奖</li><li>1966 年 5 月 15 日陈景润在什么期刊上宣布他已经证明了 (1 + 2)<br>C、《科学通报》</li><li>2001 年袁隆平又获得了<br>A、国家科学技术奖</li><li>2004 年 10 月袁隆平获得<br>C、世界粮食奖</li><li>中国科学院北京天文台发现的一颗小行星被命名为 “袁隆平星”，是什么时间<br>A、1999 年 10 月 25 日</li></ol><h2 id="center-第三章-center"><center>第三章</center></h2><ol><li>最早遗传变异研究的法国科学家拉马克在《动物学的哲学》一书中认为物种变异主要是外部环境，即提出了 () 的进化法则<br>B、用进废退</li><li>“和谐、互补和平衡” 是哪一位科学家的一辈子追求<br>C、玻尔</li><li>爱因斯坦的 “狭义相对论” 未涉及理论是<br>C、牛顿引力理论</li><li>1957，杨振宁和李政道因 () 获得诺贝尔物理学奖<br>A、宇称不守恒</li><li>最先提椭圆函数的物理学家是<br>A 阿贝尔</li><li>1897 年 () 发现了电子，从而否定了原子不可再分的论点<br>C、J. 汤姆逊</li><li>被誉为 “世界发明大王” 的是<br>C、爱迪生</li><li>《几何原本》是 () 写的<br>A、欧几里得</li><li>从事科学的人，需要有矢志不渝、迎难而上的坚强意志，更需要有 () 的博大胸怀<br>A、能输能赢<br>C、能屈能伸</li><li>哪个大学被称为是世界科学 (特别是数学) 的麦加圣地<br>B、格廷根大学</li><li>诺贝尔一生的发明极多，获得的专利就有 355 种，其中仅炸药就达 () 种<br>B、129</li><li>科学非难事是 () 说的<br>A、冯・诺伊曼</li><li>诺贝尔在他逝世的前一年，立嘱将其遗产的大部分作为基金，将每年所得利息分为 5 份，设立 ()、文学及和平 5 种奖金 (即诺贝尔奖)<br>A、物理<br>B、化学<br>C、生理或医学</li><li>Femmat “最小时间原理” 证明了光的 () 定理<br>B、折射</li><li>被译为 “博弈论教父” 的是<br>B、冯・诺伊曼</li><li>爱迪生的三大发明是：电灯和电力系统、()<br>A、留声机<br>B、电影摄影机</li></ol><h2 id="center-第四章-center"><center>第四章</center></h2><ol><li>杨振宁的导师，在美国称为 “氢弹之父” 的是<br>B、泰勒</li><li>在电磁领域中，《正弦电磁场》的作者是<br>C、哈林顿</li><li>厦大的发起人是著名教育家<br>C、陈嘉庚</li><li>《堆垒素数论》的作者是<br>A、华罗庚</li><li>卡文迪许实验室 1919-1937 年关键时期的领军人物是<br>B、卢瑟福</li><li>费根鲍姆是 () 科学的领军人物<br>C、非线性</li><li>反常是创新的最重要特征之一，创新就是 ()，反 “规律”，反逻辑<br>B、反常态<br>C、反习惯</li><li>《导波场论》的作者是<br>A、柯林</li><li>“提出一个问题往往比解决一个问题更重要” 是谁的名句<br>A、爱因斯坦</li><li>“运用脑髓，放出眼光。” 是谁的名句<br>B、鲁迅</li><li>由 () 领军研制成的世界第一名电子计算机 EANIC 机<br>C、冯・诺伊曼</li><li>恩里科・费米是哪一国籍的科学家<br>A、意大利</li><li>从 50 年代后期至 60 年代，李四光率领的勘探部门相继找到了华北油田以及哪些油田<br>A、大庆油田<br>B、大港油田<br>C、胜利油田</li><li>要投入创新这个事业，必须要对困难作出足够的准备，必须有 () 的精神<br>B、坚持忍耐</li><li>要有一个适合创新人才生长的学术民主和 () 的土壤，就一定会出尖子人才：不是张三就是李四<br>B、科学自由</li><li>创新必须是独立思考的，() 说到底在科学的思考中必须有自己独立的一根主心骨，这正是科学道德的根本<br>A、不人云亦云的<br>B、不看风使舵的<br>C、不见利忘义的</li></ol><h2 id="center-第五章-center"><center>第五章</center></h2><ol><li>被称为 “杂交水稻之父” 的是<br>A、袁隆平</li><li>下列哪个时期偏离了实事求是<br>B、大跃进</li><li>《女神》的作者是谁<br>A、郭沫若</li><li>“学习是一件老老实实的事，来不得半点虚假。” 这句话是谁说的<br>B、毛泽东</li><li>1976 年，由于发现了 J 粒子而获得诺贝尔物理学奖<br>C、丁肇中</li><li>真正把电和磁首先联系起来的科学家是<br>B、奥斯特</li><li>() 提出了电磁感应定律<br>A、法拉第</li><li>() 大胆预言了电磁波的存在<br>C、（麦）克斯韦</li><li>下列哪个科学家没有获得过诺贝尔奖<br>C、钱学森</li><li>题目为 “大师一问三不知” 的文章是写 () 的<br>C、丁肇中</li><li>开普勒是 () 国天文学家<br>A、德</li><li>“每一行星的矢径在相等的时间内扫过相同的面积。” 是开普勒第 () 定律<br>B、二</li><li>“人有多大胆，地有多大产。” 是在哪个时期提出的<br>B、大跃进</li><li>1957 年，杨振宁与 () 因共同提出宇称不守恒理论而获得了诺贝尔物理学奖<br>A、李政道</li><li>() 是物理史上提出力线和场观点的第一人<br>A、法拉第</li><li>麦克斯韦提出了著名的位移电流思想<br>√</li><li>奥斯特证明了电能产生磁，法拉第根据对称性得出了电磁感应定律<br>√</li><li>“水变油” 和 “轮船中翼舵” 违背了实事求是的原则<br>√</li><li>发现了法拉第的大科学家戴维是物理学家<br>×</li><li>杨振宁博士把 “场” 的发现认为是 20 世纪物理学中非常重要的概念<br>√</li></ol><h2 id="center-第六章-center"><center>第六章</center></h2><ol><li>“慎而思之，勤而行之。” 出自唐朝哪位诗人<br>B、白居易</li><li>“世界上怕就怕 “认真’二字。” 出自哪位名人<br>C、毛泽东</li><li>1957，杨振宁和李政道因 () 获得诺贝尔物理学奖<br>A 宇称不守恒</li><li>1956 年，在第六届国际高能物理会议上，() 应邀在会上就 “0 - T 之谜” 及当时的粒子物理理论作了一个引介的报告<br>A、杨振宁</li><li>最先提出宇称概念的物理学家之一的是<br>A、维格纳</li><li>1962 年诺贝尔物理学奖的惟一得主朗道是哪个国家的科学家<br>C、苏联</li><li>() 首先完成 “极化核 B 衰变” 实验<br>C、吴健雄</li><li>《几何原本》是 () 写的<br>A、欧几里得</li><li>匈牙利 “数学之父” 是<br>A、费耶</li><li>哪个大学被称为是世界科学 (特别是数学) 的麦加圣地<br>B、格廷根大学</li><li>被译为雷达 “保护神” 的是<br>B、保铮</li><li>科学非难事是 () 说的<br>A、冯・诺伊曼</li><li>“差之毫厘，谬以千里” 出自<br>A、《史记》</li><li>Femmat “最小时间原理” 证明了光的 () 定理<br>B、折射</li><li>被译为 “博弈论教父” 的是<br>B、冯・诺伊曼</li><li>1954 年至 1956 年，杨振宁和李政道都在普林斯顿大学<br>×</li><li>Femmat 最小时间原理与 Snell 折射定律等价<br>√</li><li>保铮是中国第一届雷达毕业生，当时老师是毕德显<br>√</li><li>冯・诺伊曼在 18 岁 (1921 年) 和老师费耶合写第一数学论文并发表<br>×</li><li>冯・诺伊曼的理论创新顶峰是在普林斯顿大学<br>√</li></ol><h2 id="center-第七章-center"><center>第七章</center></h2><ol><li>康托尔提出了<font color="green"><strong>超限数论</strong></font></li><li><font color="green"><strong>曼德勃罗</strong></font>提出任何海岸线是一定意义上应该是无限长的</li><li>混沌之父是<font color="green"><strong>洛伦兹</strong></font></li><li><font color="green"><strong>薛定谔</strong></font>通过对于事物矛盾的分析成了 “分子生物学” 的开山鼻祖</li><li>列宁在《哲学笔记》中写道芝诺的特点是<font color="green"><strong>辩证法</strong></font>，他是辩证法的师祖</li><li>薛定谔对分子生物学的怀疑包含<br>A、遗传靠什么<br>B、优良品种为什么会退化<br>C、遗传疾病机理<br>D、生命存在的原因</li><li>《几何原本》的作者是<br>A、罗巴切夫斯基</li><li>芝诺提出的著名 “悖论” 分别<br>A、阿基里斯追龟<br>B、飞矢不动<br>C、运动根本不存在<br>D、1 / 2 时间 = 全部时间</li><li>青年学者存在的问题往往是从何怀疑起<br>A、本身<br>B、空间<br>C、时间<br>D、逻辑<br>E、数量</li><li>天问的作者是<br>C、屈原</li></ol><h2 id="center-第八章-center"><center>第八章</center></h2><ol><li>传奇数学家<font color="green"><strong>爱多士</strong></font>是开放的头脑的典型例子</li><li>欧拉创立了<font color="green"><strong>变分理论</strong></font></li><li>前国际乒联主席<font color="green"><strong>徐寅生</strong></font>同志，在 1965 年有一篇著名的讲话《关于如何打乒乓球》</li><li>开放的头脑所应该具备的品质<br>A、在时间上向前看<br>B、在空间 V 上充分向外扩展<br>C、在知识结构上要交叉互补<br>D、在思维上必须海绵型的大量吸收各家所长</li><li>开放的头脑要求在知识结构上交叉互补，其中包括<br>A、理和文的适当平衡<br>B、数和形的适当平衡<br>C、思想和工具 (方法) 的适当平衡<br>D、直观和理论的适当平衡</li><li>开放的胸怀包括<br>A、开放不怕羞<br>B、开放不怕杂<br>C、开放就不怕超</li><li>学术开放的体制包括<br>A、会议体制<br>B、Seminar 体制</li><li>学术开放的环境包括<br>A、平等自由的环境<br>B、交叉融合的环境<br>C、兼容并包的环境<br>D、百花齐放百家争鸣</li><li>Hilbert 的成名作<font color="green"><strong>《几何学基础》</strong></font></li><li>Hilbert 的导师有<br>A、克莱因<br>B、彭加勒<br>C、闵可夫斯基</li></ol><h2 id="center-第九章-center"><center>第九章</center></h2><ol><li>颜回是哪位国学大师的学生<br>A、孔子</li><li>“海纳百川，有容乃大，襟三江而带五湖。” 出自哪位名人<br>B、墨子</li><li>西游记的作者是<br>C、吴承恩</li><li>“不受苦中苦，难为人上人” 出自哪位名人<br>B、吴承恩</li><li>古典名著《水浒传》里人物林冲的外号是<br>C、豹子头</li><li>“恩仇不辨非豪杰，黑白未分是丈夫” 出自哪位名人<br>A、施耐庵</li><li>“勿以恶小而为之，勿以善小而不为” 出自古典名著《三国》里的哪个人物<br>A、刘备</li><li>“三顾频繁天下计，两朝开济老臣心” 指的是三国演义里的哪个人物<br>C、诸葛亮</li><li>“壶浊酒喜相逢，古今多少事，都付笑谈中” 出自哪位名人<br>C、罗贯中</li><li>巴丁团队因为 () 工作获得 1972 年诺贝尔奖<br>A、超导的微观理论</li><li>提出基态试探函数并导出能隙方程的科学家是<br>C、施里弗</li><li>诺伯特・维纳是哪国的科学家<br>A、美国</li><li>控制论中的最重要的一个概念是<br>C、反馈</li><li>哥本哈根学派的领袖是<br>B、波尔</li><li>中国自主研发的全球定位导航系统的名称是<br>C、北斗</li><li>西游记里的白龙马是东海龙王三太子化身而成<br>×</li><li>薛定谔、海森堡和狄拉克都是哥本哈根学派成员<br>×</li><li>库珀基于电子 - 声子相互作用，提出了超导理论中至关重要的概念：电子对<br>√</li><li>中国北斗卫星导航系统是继美国全球定位系统 (GPS) 俄罗斯格洛纳斯卫星导航系统 (GLONASS) 之后第三个成熟的卫星导航系统<br>√</li><li>中国探月工程又叫嫦娥工程<br>√</li></ol><h2 id="center-第十章-center"><center>第十章</center></h2><ol><li>卡文迪许实验室位于哪所知名大学<br>B、剑桥</li><li>卢瑟福是接替哪位科学家成为卡文迪许实验室主任<br>A、J.J. 汤姆逊</li><li>俄罗斯著名科学家卡皮查在 1937 年纪念卢瑟福逝世的演讲中把他的精神概括为<br>C、鳄鱼精神</li><li>卡皮查是哪国物理学家<br>B、苏联</li><li>恩里科・费米是哪国物理学家<br>C、意大利</li><li>费米移民到美国后在哪所大学任教<br>C、芝加哥大学</li><li>布鲁塞尔学派的领军人物是<br>A、普利高津</li><li>哥廷根大学位于哪个国家<br>C、德国</li><li>享有 “数学王子” 之称的是<br>C、高斯</li><li>1900 年 8 月 8 日在巴黎第二届国际数学家大会上，() 提出了新世纪数学家应当努力解决的 23 个数学问题<br>A、希尔伯特</li><li>中国知名物理学家黄昆和程开甲的老师是<br>C、波恩</li><li>普林斯顿高等研究所位于哪个国家<br>A、美国</li><li>分形理论的创始人是<br>C、曼德勃罗</li><li>被称为美国原子弹之父的科学家是<br>B、奥本海默</li><li>相对论的提出者是<br>C、爱因斯坦</li><li>超弦的探索者是施瓦兹<br>√</li><li>ENIAC 计算机总师是冯・诺伊曼<br>√</li><li>爱因斯坦由于相对论的提出而获得 1921 年诺贝尔物理奖<br>×</li><li>打破数学逻辑完美性的科学家是哥德尔<br>√</li><li>罗马学派和芝加哥学派的领军人物都是费米<br>√</li></ol><h2 id="参考博客">参考博客</h2><ul><li><a href="https://blog.csdn.net/qq_45020818/article/details/128327757" target="_blank" rel="noopener noreferrer">西电雨课堂等网课测试大合集</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;font size=&quot;4&quot; color=&quot;00b9ff&quot;&gt;前言：期末考试从章节练习题中选取，不会单独列出。所有题目由我自行整理。&lt;/font&gt;&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;&lt;font size=&quot;3&quot; color=&quot;#28b463&quot;&gt;考试成绩</summary>
      
    
    
    
    <category term="课程答案" scheme="https://luotian.cyou/categories/%E8%AF%BE%E7%A8%8B%E7%AD%94%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>西电通院信号与系统大作业 — 无线传输</title>
    <link href="https://luotian.cyou/post/Signals-Syss.html"/>
    <id>https://luotian.cyou/post/Signals-Syss.html</id>
    <published>2025-06-04T10:06:52.000Z</published>
    <updated>2025-07-09T18:11:08.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、题目描述">一、题目描述</h2><p>  考虑一个余弦信号 $\small {x\left (t \right) =\cos \left (2\pi f_0t \right)}$ 沿着一条受到多径效应和多普勒效应影响的信道传输的情形。设有两条路径，并且假定该正弦信号正由一个移动的物体发出，因此会发生多普勒频移。设接收信号为：</p><p>$$<br>\begin{aligned}<br>r\left( t \right) =a_0\cos\left( 2\pi \left( f_0-v \right) \left( t-\dfrac{L_0}{c} \right) \right) +a_1\cos\left( 2\pi \left( f_0-v \right) \left( t-\dfrac{L_1}{c} \right) \right)<br>\end{aligned}<br>$$</p><p>  其中 $\small {0\le a_i\le 1,i = 0,1}$ 为衰减因子，$\small {L_i}$ 代表第 $\small {i}$ 条路径上发射机与接收机之间的距离，$\small {c = 3\times 10^3m / s}$，$\small {v}$ 是多普勒效应引起的频移。</p><h2 id="二、问题回答">二、问题回答</h2><p>  设 $\small {r_0 (t)}$ 和 $\small {r_1 (t)}$ 分别为两条信号路径分量，即：</p><p>$$r_0(t) = a_0\cos\left[2\pi\left(f_0-v\right)\left(t-\frac{L_0}{c}\right)\right]$$</p><p>$$r_1(t) = a_1\cos\left[2\pi\left(f_0-v\right)\left(t-\frac{L_1}{c}\right)\right]<br>$$</p><h3 id="2-1-问题1">2.1 问题 1</h3><p>  令 $\small {f_0 = 2 \mathrm {kHz}, v = 50\mathrm {Hz}, a_0 = 1, a_1 = 0.9}$。令 $\small {L_0 = 10000 m}$，如果两个余弦信号的相位差等于 $\small {\pi / 2}$，$\small {L_1}$ 应该等于多少？</p><p>  <strong>答：</strong><br>  上述数据带入 $\small {r_0 (t)}$ 和 $\small {r_1 (t)}$ 中得：</p><p>$$\varphi_0 = -13000\pi$$</p><p>$$\varphi_1 = -\frac{13}{10}\pi L_1$$</p><p>  由于 $\small {\Delta\varphi=\left (2n+\frac {1}{2}\right)\pi}$，因此：<br>$$13000\pi - \frac{13}{10}\pi L_1 = \left(2n+\frac{1}{2}\right)\pi, \quad n\in \mathbf{Z}$$<br>  解得：<br>$$L_1 = \frac{129995}{13} - \frac{20}{13}n, \quad n\in \mathbf{Z}$$<br>  当 $\small {n = 0}$ 时，$\small {L_1=\frac {129995}{13} m \approx 9999.62 m}$。</p><h3 id="2-2-问题2">2.2 问题 2</h3><p>  若各参数同上，但 $\small {L_1 = 10000 m}$，那么接收信号 $\small {r (t)}$ 是周期的吗？如果 $\small {r (t)}$ 是周期的，那么它的周期等于多少？它的周期与原始余弦信号的周期相差多少？如果将传输信道看作为一个系统，$\small {x (t)}$ 是其输入，$\small {r (t)}$ 是其输出，那么该系统是线性的和时不变的吗？请作出解释。<br>  <strong>答：</strong><br>  将所给数据代入 $\small {r (t)}$ 中得：<br>$$r(t) = 1.9\cos(3900\pi t - 13000\pi)$$<br>  可以发现 $\small {r (t)}$ 是周期信号，其周期 $\small {T=\frac {2\pi}{\omega} \approx 5.13 \times 10^{-4} s}$。<br>  将数据代入得：<br>$$x(t)=\cos(4000\pi t)$$<br>  可知周期 $\small {T_x = 5 \times 10^{-4} s}$，因此二者周期差为：<br>$$\Delta T = \frac{1}{78000} s \approx 1.28 \times 10^{-5} s$$<br>  下面判断该系统是否为线性系统，是否为时不变系统。</p><p>  根据 $\small {r (t)}$ 和 $\small {x (t)}$ 的解析式可以得出二者满足以下关系：<br>$$r\left( t \right) =1.9x\left( \frac{39}{40}t \right) $$</p><ul><li><p><strong>线性系统的判断</strong></p><p>对假设两个输入 $\small {x_1 (t), x_2 (t)}$ 分别对应输出 $\small {r_1 (t), r_2 (t)}$，即：<br>$$r_1(t) = 1.9 x_1\left(\frac{39}{40}t\right)$$<br>$$r_2(t) = 1.9 x_2\left(\frac{39}{40}t\right)$$<br>当输入为 $\small {ax_1 (t) + bx_2 (t)}$ 时，输出为：</p><p>$$<br>\begin{aligned}<br>r(t) &amp;= 1.9a x_1\left(\frac{39}{40}t\right) + 1.9b x_2\left(\frac{39}{40}t\right)<br>\end{aligned}<br>$$</p><p>因此该系统是<strong>线性</strong>的。</p></li><li><p><strong>时不变系统的判断</strong>：<br>对输入 $\small {x (t)}$ 有：<br>$$r\left( t \right) =1.9x\left( \frac{39}{40}t \right) $$<br>令输入产生 $\small {t_d}$ 的时移即 $\small {x (t-t_d)}$，有：</p><p>$$ r’\left( t \right) =1.9x\left( \frac{39}{40}t-t_d \right) $$</p><p>$$r(t-t_d) = 1.9 x\left(\frac{39}{40}(t-t_d)\right) = 1.9 x\left(\frac{39}{40}t - \frac{39}{40}t_d\right)$$<br>显然有：<br>$$r’(t) \neq r(t-t_d)$$<br>系统为<strong>时变系统</strong>。</p></li></ul><h3 id="2-3-问题3">2.3 问题 3</h3><p>  对信号 $\small {x (t)}$ 和 $\small {r (t)}$ 以抽样频率 $ \small {F_s = 10\mathrm {kHz<br>}}$ 进行抽样，画出抽样后的发送信号 $\small {x (n T_s)}$ 和接收信号 $\small {r (n T_s)}$ 的图形，取 $\small {n = 0\sim 2000}$。</p><p>  <strong>答：</strong></p><ul><li><p><strong>对 $\small {x (t)}$ 进行采样</strong>：</p><p>  原始余弦信号 $\small {x\left (t \right) =\cos \left (2\pi f_0t \right)}$。以抽样频率 $\small {F_s = 10\mathrm {kHz}}$ 进行取样，则取样周期 $\small {T_s = 10^{-4} s}$，取样函数为：<br>$$s\left( t \right) =\sum_{n=-\infty}^{+\infty}{\delta \left( t-10^{-4}n \right)}$$<br>  则取样信号：<br>$$x_s\left( t \right) =\cos \left( 2\pi f_0t \right) \sum_{n=-\infty}^{+\infty}{\delta \left( t-10^{-4}n \right)}$$</p><p>  由于不同的 $\small {f_0}$ 在抽样频率一定的情况下会对 $\small {x (nT_s)}$ 产生不同的结果，因此取 $\small {f_0 = 2\mathrm {kHz},7\mathrm {kHz}}$，采用 MATLAB 进行仿真，结果如图所示：</p><center>$\small {f_0 = 2\mathrm {kHz}}$ 下的 $\small {x (t)}$ 抽样结果图</center><p><img src="/img/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/x_2k.png" alt="x_2k"></p><center>$\small {f_0 = 7\mathrm {kHz}}$ 下的 $\small {x (t)}$ 抽样结果图</center><p><img src="/img/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/x_7k.png" alt="x_7k"></p><p>  由图可以发现，信号频率为 $\small { 2\mathrm {kHz}} $ 时，抽样图形很明显地呈现了原始信号的特征，而信号频率为 $\small { 7\mathrm {kHz}} $ 时，在采样信号的过程中出现了信号混叠的现象。这是因为采样允许的最小频率至少应为原信号最高频率的两倍，该频率称为奈奎斯特频率。当取样的信号频率为 $\small { 2\mathrm {kHz}} $ 时，奈奎斯特频率为 $\small { 4\mathrm {kHz}} $，$\small { F_s = 10\mathrm {kHz}} $ 符合采样要求；当取样的信号频率为 $\small { 7\mathrm {kHz}} $ 时，$\small {F_s} $ 将不符合采样要求。因此，选择的信号频率应当低于 $\small { 5\mathrm {kHz} }$。</p></li><li><p><strong>对 $\small {r (t)}$ 进行采样：</strong></p><p>  接收信号 $\small {r (t)}$，以抽样频率 $\small { F_s = 10\mathrm {kHz} }$ 进行取样，则取样周期 $\small { T_s = 10^{-4} s}$，取样函数为：</p><p>$$s\left( t \right) =\sum_{n=-\infty}^{+\infty}{\delta \left( t-10^{-4}n \right)}$$</p><p>  则取样信号：</p><p>$$r_s\left( t \right) =\mathrm{r(}t)\sum_{n=-\infty}^{+\infty}{\delta \left( t-10^{-4}n \right)}$$</p><p>  选取信号频率 $\small { f_0 = 2\mathrm {kHz}}$，其余条件同问题 2，则：</p><p>$$r_s\left( t \right) =1.9\cos\left( 3900\pi t-13000\pi \right) \sum_{n=-\infty}^{+\infty}{\delta \left( t-10^{-4}n \right)}$$</p><p>  采用 MATLAB 进行仿真，结果如图所示：</p><p><img src="/img/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/r_2k.png" alt="r_2k"></p></li></ul><h3 id="2-4-问题4">2.4 问题 4</h3><p>  考虑这样一种情形，其中 $\small {f_0 = 2\mathrm {kHz}}$，但路径参数是随机的。尝试模拟一种真实情形，其中路径参数都是不可预测的（虽然它们之间仍存在某种关系）。令</p><p>$$r\left( t \right) =a_0\cos\left( 2\pi \left( f_0-v \right) \left( t-\frac{L_0}{c} \right) \right) +a_1\cos\left( 2\pi \left( f_0-v \right) \left( t-\frac{L_1}{c} \right) \right) $$</p><p>  其中，$\small {v = 50η\mathrm {Hz}}$，$\small {L_0 = 1000η}$ 及 $\small {L_1 = 10000η}$，$\small {a_0 = 1-η}$ 及 $\small {a_1 = a_0 / 10}$，$\small {η} $ 是一个介于 0 和 1 之间的随机数，并且它等于 0 和 1 之间任何一个数的概率是一样的（可利用 MATLAB 的函数 rand 来实现）。用 $\small { F_s = 10000\mathrm {Hz}} $ 作为抽样频率，产生出 10 种不同情况下的接收信号，并将它们画在一起，从中观察多径效应和多普勒效应。对于这 10 种不同情况，求出结果信号并画出来。</p><p>  <strong>答：</strong></p><p>  使用 MATLAB 模拟生成十种不同的接收信号：</p><center>接收信号模拟图 1</center><p><img src="/img/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/random_1.png" alt="random1"></p><center>接收信号模拟图 2</center><p><img src="/img/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/random_2.png" alt="random2"></p><center>接收信号模拟图 3</center><p><img src="/img/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/random_3.png" alt="random3"></p><center>接收信号模拟图 4</center><p><img src="/img/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/random_4.png" alt="random4"></p><p>  通过上述图形分析可以得出信号在传播过程中产生了明显的衰落，使结果信号的多径效应十分显著，许多信号的采样峰值都明显小于 1。信号在传播过程中产生了明显的频率变化，能够显著地观察到多普勒效应。其中多普勒效应最明显的信号甚至不能在图中完整地展示其一个周期。</p><h2 id="三、参考文献">三、参考文献</h2><blockquote><p>[1] 信号与线性系统分析，吴大正 杨林耀 张永瑞 王松林 郭宝龙，2019.3<br>[2] <a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/help.html" target="_blank" rel="noopener noreferrer">https://ww2.mathworks.cn/help/matlab/learn_matlab/help.html</a></p></blockquote><h2 id="四、附录">四、附录</h2><center>$\small {x (t)} $ 信号抽样代码</center><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">%f_0 = 2000Hz</span></span><br><span class="line">clc; clear</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">x = [];</span><br><span class="line">f_0 = <span class="number">2000</span>;<span class="comment">%设置信号频率</span></span><br><span class="line"><span class="keyword">for</span> t = <span class="number">0</span> : <span class="number">0.000001</span> : <span class="number">0.005</span><span class="comment">%设置for循环，循环时间t</span></span><br><span class="line">    x_t = <span class="number">0</span>;<span class="comment">%每个点取样后的信号值</span></span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">0</span>:<span class="number">2000</span><span class="comment">%设置for循环，循环抽样点n</span></span><br><span class="line">        x_temp = <span class="built_in">cos</span>(f_0 * <span class="number">2</span> * <span class="built_in">pi</span> .* t) * delta(t - <span class="number">0.0001</span> * n);<span class="comment">%计算原信号值和冲激函数的乘积</span></span><br><span class="line">        x_t = x_t + x_temp;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x = [x, x_t];<span class="comment">%结果保存到x[]中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t = <span class="number">0</span> : <span class="number">0.000001</span> : <span class="number">0.005</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(f_0 * <span class="number">2</span> * <span class="built_in">pi</span> .* t);</span><br><span class="line"><span class="built_in">plot</span>(t, x)<span class="comment">%画出抽样后的函数图像</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t, y)<span class="comment">%画出原函数图像</span></span><br><span class="line"><span class="comment">%设置图例</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'\fontname{Times New Roman}\fontsize{12}x(nT_s)'</span>,<span class="string">'\fontname{Times New Roman}\fontsize{12}x(t)'</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%f_0 = 7000Hz</span></span><br><span class="line">clc; clear</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">x = [];</span><br><span class="line">f_0 = <span class="number">7000</span>;<span class="comment">%设置信号频率</span></span><br><span class="line"><span class="keyword">for</span> t = <span class="number">0</span> : <span class="number">0.000001</span> : <span class="number">0.003</span><span class="comment">%设置for循环，循环时间t</span></span><br><span class="line">    x_t = <span class="number">0</span>;<span class="comment">%每个点取样后的信号值</span></span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">0</span>:<span class="number">2000</span><span class="comment">%设置for循环，循环抽样点n</span></span><br><span class="line">        x_temp = <span class="built_in">cos</span>(f_0 * <span class="number">2</span> * <span class="built_in">pi</span> .* t) * delta(t - <span class="number">0.0001</span> * n);<span class="comment">%计算原信号值和冲激函数的乘积</span></span><br><span class="line">        x_t = x_t + x_temp;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    x = [x, x_t];<span class="comment">%结果保存到x[]中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t = <span class="number">0</span> : <span class="number">0.000001</span> : <span class="number">0.003</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(f_0 * <span class="number">2</span> * <span class="built_in">pi</span> .* t);</span><br><span class="line"><span class="built_in">plot</span>(t, x)<span class="comment">%画出抽样后的函数图像</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t, y)<span class="comment">%画出原函数图像</span></span><br><span class="line"><span class="comment">%设置图例</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'\fontname{Times New Roman}\fontsize{12}x(nT_s)'</span>,<span class="string">'\fontname{Times New Roman}\fontsize{12}x(t)'</span>);</span><br></pre></td></tr></tbody></table></figure><center>$\small {r (t)}$ 信号抽样代码</center><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">clc; clear</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">r = [];</span><br><span class="line"><span class="keyword">for</span> t = <span class="number">0</span> : <span class="number">0.000001</span> : <span class="number">0.005</span><span class="comment">%设置for循环，循环时间t</span></span><br><span class="line">    <span class="comment">%每个点取样后的信号值</span></span><br><span class="line">    r_t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> n = <span class="number">0</span>:<span class="number">2000</span><span class="comment">%设置for循环，循环抽样点n</span></span><br><span class="line">        r_temp = <span class="number">1.9</span> .* <span class="built_in">cos</span>(<span class="number">3900</span> * <span class="built_in">pi</span> .* t - <span class="number">13000</span> * <span class="built_in">pi</span>) * delta(t - <span class="number">0.0001</span> * n);<span class="comment">%计算原信号值和冲激函数的乘积</span></span><br><span class="line">        r_t = r_t + r_temp;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    r = [r, r_t];<span class="comment">%结果保存到r[]中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">t = <span class="number">0</span> : <span class="number">0.000001</span> : <span class="number">0.005</span>;</span><br><span class="line">y = <span class="number">1.9</span> .* <span class="built_in">cos</span>(<span class="number">3900</span> * <span class="built_in">pi</span> .* t - <span class="number">13000</span> * <span class="built_in">pi</span>);</span><br><span class="line"><span class="built_in">plot</span>(t, r)<span class="comment">%画出抽样后的函数图像</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t, y)<span class="comment">%画出原函数图像</span></span><br><span class="line"><span class="comment">%设置图例</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'\fontname{Times New Roman}\fontsize{12}r(nT_s)'</span>,<span class="string">'\fontname{Times New Roman}\fontsize{12}r(t)'</span>);</span><br></pre></td></tr></tbody></table></figure><center>模拟信号生成代码</center><figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">clc; clear</span><br><span class="line">r = [];</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span> : <span class="number">10</span><span class="comment">%设置循环，生成10个随机信号</span></span><br><span class="line">    r = [];<span class="comment">%结果保存数组</span></span><br><span class="line">    eta = <span class="built_in">rand</span>;<span class="comment">%获取0-1之间的随机数，存入eta中</span></span><br><span class="line">    f_0 = <span class="number">2000</span>;<span class="comment">%设置信号频率</span></span><br><span class="line">    <span class="keyword">for</span> t = <span class="number">0</span> : <span class="number">0.000001</span> : <span class="number">0.05</span><span class="comment">%设置for循环，循环时间t</span></span><br><span class="line">        r_t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> n = <span class="number">0</span> : <span class="number">2000</span><span class="comment">%设置for循环，循环抽样点n</span></span><br><span class="line">            r_temp = ((<span class="number">1</span> - eta) * <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (f_0 - <span class="number">50</span> * eta) * (t - <span class="number">1000</span> * eta / <span class="number">3000</span>)) + ...</span><br><span class="line">                (<span class="number">1</span> - eta) / <span class="number">10</span> * <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (f_0 - <span class="number">50</span> * eta) * (t - <span class="number">10000</span> * eta / <span class="number">3000</span>))) * ...</span><br><span class="line">                delta(t - <span class="number">0.0001</span> * n);<span class="comment">%计算原信号值和冲激函数的乘积</span></span><br><span class="line">            r_t = r_t + r_temp;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        r = [r, r_t];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    t = <span class="number">0</span> : <span class="number">0.000001</span> : <span class="number">0.05</span>;</span><br><span class="line">    <span class="built_in">plot</span>(t, r)<span class="comment">%绘制图像</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、题目描述&quot;&gt;一、题目描述&lt;/h2&gt;
&lt;p&gt;  考虑一个余弦信号 $&#92;small {x&#92;left (t &#92;right) =&#92;cos &#92;left (2&#92;pi f_0t &#92;right)}$ 沿着一条受到多径效应和多普勒效应影响的信道传输的情形。设有两条路径，并且假定</summary>
      
    
    
    
    <category term="课程作业" scheme="https://luotian.cyou/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>西电通院微处理器大作业 — 数码管显示</title>
    <link href="https://luotian.cyou/post/micropc-sys.html"/>
    <id>https://luotian.cyou/post/micropc-sys.html</id>
    <published>2025-06-04T09:18:19.000Z</published>
    <updated>2025-07-09T18:11:34.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、实验要求">一、实验要求</h2><p>  ARM Cortex-M3 微处理器使用端口 GPIOA 控制一片七段数码管（共阳极），按键 K 连接 GPIOA15 管脚。<br>  实现下述功能：使用查询方式查询按键状态，当按键打开时， GPIOA15 管脚为 “0” ，数码管显示 0；当按键闭合时，GPIOA15 管脚为 “1”，数码管显示自己的学号，每隔 1 秒显示 1 位，显示结束后，数码管灯关闭。</p><h2 id="二、实现流程">二、实现流程</h2><p><img src="/img/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/1.png" alt="流程图"></p><h2 id="三、实验代码">三、实验代码</h2><h3 id="3-1-写入中断向量">3.1 写入中断向量</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">AREA RESET,CODE</span><br><span class="line">EXPORT __Vectors</span><br><span class="line">EXPORT Reset_Handler</span><br><span class="line">__Vectors</span><br><span class="line">DCD __initial_sp</span><br><span class="line">DCD Reset_Handler</span><br><span class="line">SPACE <span class="number">39</span>*<span class="number">4</span></span><br><span class="line">IMPORT DISPLAY</span><br><span class="line">DCD DISPLAY</span><br><span class="line">Reset_Handler PROC</span><br><span class="line">IMPORT main</span><br><span class="line">ldr r1,=main</span><br><span class="line">bx r1</span><br><span class="line">B .</span><br><span class="line">ENDP</span><br><span class="line"></span><br><span class="line">   NOP</span><br><span class="line"></span><br><span class="line">AREA STACK,DATA</span><br><span class="line">SPACE <span class="number">0x100</span></span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-程序代码">3.2 程序代码</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"usrt1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">INIT</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//使能GPIOA</span></span><br><span class="line">RCC-&gt;APB2ENR = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">//使能TIM1</span></span><br><span class="line">RCC-&gt;APB2ENR = <span class="number">1</span> &lt;&lt; <span class="number">11</span>;</span><br><span class="line"><span class="comment">//配置GPIOA的输入输出模式</span></span><br><span class="line"><span class="comment">//PA15为上拉/下拉输入模式</span></span><br><span class="line"><span class="comment">//PA8-14为输出模式</span></span><br><span class="line"> GPIOA-&gt;CRH = <span class="number">0x43333333</span>;</span><br><span class="line"><span class="comment">//f=8M/(7999+1)=1kHz；</span></span><br><span class="line">TIM1-&gt;PSC = <span class="number">7999</span>;</span><br><span class="line"><span class="comment">//自动重装载寄存器值为999</span></span><br><span class="line">TIM1-&gt;ARR = <span class="number">999</span>;</span><br><span class="line">NVIC-&gt;ISER[<span class="number">0</span>] = <span class="number">0x1</span> &lt;&lt; <span class="number">25</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//计数变量</span></span><br><span class="line"><span class="type">int</span> Cout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学号直接定义在数组中</span></span><br><span class="line"><span class="comment">//假设数码管为共阳七段数码管，而输出为GPIOA8-14,一共7个管脚</span></span><br><span class="line"><span class="comment">//字形码对应为  0-0x40  1-0x79  2-0x24  3-0x30  4-0x19</span></span><br><span class="line"><span class="comment">//              5-0x12  6-0x02  7-0x78  8-0x00  9-0x10</span></span><br><span class="line"><span class="comment">//自己的学号为21009102029</span></span><br><span class="line"><span class="type">int</span> NUM[<span class="number">11</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">NUM_INIT</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">NUM[<span class="number">0</span>] = <span class="number">0x2400</span>;<span class="comment">//2</span></span><br><span class="line">NUM[<span class="number">1</span>] = <span class="number">0x7900</span>;<span class="comment">//1</span></span><br><span class="line">NUM[<span class="number">2</span>] = <span class="number">0x4000</span>;<span class="comment">//0</span></span><br><span class="line">NUM[<span class="number">3</span>] = <span class="number">0x4000</span>;<span class="comment">//0</span></span><br><span class="line">NUM[<span class="number">4</span>] = <span class="number">0x1000</span>;<span class="comment">//9</span></span><br><span class="line">NUM[<span class="number">5</span>] = <span class="number">0x7900</span>;<span class="comment">//1</span></span><br><span class="line">NUM[<span class="number">6</span>] = <span class="number">0x4000</span>;<span class="comment">//0</span></span><br><span class="line">NUM[<span class="number">7</span>] = <span class="number">0x2400</span>;<span class="comment">//2</span></span><br><span class="line">NUM[<span class="number">8</span>] = <span class="number">0x4000</span>;<span class="comment">//0</span></span><br><span class="line">NUM[<span class="number">9</span>] = <span class="number">0x2400</span>;<span class="comment">//2</span></span><br><span class="line">NUM[<span class="number">10</span>] = <span class="number">0x1000</span>; <span class="comment">//9</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DISPLAY</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//状态寄存器清零</span></span><br><span class="line">TIM1-&gt;SR = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//输出学号</span></span><br><span class="line">GPIOA-&gt;ODR = NUM[Cout];</span><br><span class="line">Cout++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//输入标志变量</span></span><br><span class="line"><span class="type">int</span> Flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序初始化</span></span><br><span class="line">INIT();</span><br><span class="line">NUM_INIT();</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//将PA15的值传递到Flag</span></span><br><span class="line">Flag = GPIOA-&gt;IDR &gt;&gt; <span class="number">15</span>;</span><br><span class="line"><span class="comment">//显示为0</span></span><br><span class="line"><span class="keyword">if</span>(Flag == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//允许更新中断并使能计数器</span></span><br><span class="line">TIM1-&gt;DIER = <span class="number">1</span>;</span><br><span class="line">TIM1-&gt;CR1 = <span class="number">0x81</span>;</span><br><span class="line"><span class="comment">//不显示</span></span><br><span class="line"><span class="keyword">if</span>(Cout &gt; <span class="number">11</span>)</span><br><span class="line">GPIOA-&gt;ODR = <span class="number">0x7f00</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">GPIOA-&gt;ODR = <span class="number">0x4000</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="四、代码演示">四、代码演示</h2><p><a href="/video/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F/1.mp4">点此查看视频</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、实验要求&quot;&gt;一、实验要求&lt;/h2&gt;
&lt;p&gt;  ARM Cortex-M3 微处理器使用端口 GPIOA 控制一片七段数码管（共阳极），按键 K 连接 GPIOA15 管脚。&lt;br&gt;
  实现下述功能：使用查询方式查询按键状态，当按键打开时， GPIOA15 管</summary>
      
    
    
    
    <category term="课程作业" scheme="https://luotian.cyou/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenMMLab-4</title>
    <link href="https://luotian.cyou/post/MMLab-4.html"/>
    <id>https://luotian.cyou/post/MMLab-4.html</id>
    <published>2023-02-10T08:58:22.000Z</published>
    <updated>2025-07-09T18:12:55.546Z</updated>
    
    <content type="html"><![CDATA[<p><strong>目标检测基础与 MMDet</strong></p><h2 id="目标检测简介">目标检测简介</h2><h3 id="实例应用">实例应用</h3><ul><li>人脸识别<br>身份识别、属性分析<br>…</li><li>智慧城市<br>垃圾检测、非法占道检测、违章停车检测、危险物体检测、自助服务、烟雾和火灾检测、标准着装检测、危险行为检测<br>…</li><li>自动驾驶<br>环境感知、路径规划与控制<br>…</li><li>下游视觉任务<br>文字之别、人体姿态估计<br>…</li></ul><h3 id="滑窗">滑窗</h3><p>Sliding Window</p><blockquote><p>未完待续…</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;目标检测基础与 MMDet&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;目标检测简介&quot;&gt;目标检测简介&lt;/h2&gt;
&lt;h3 id=&quot;实例应用&quot;&gt;实例应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;人脸识别&lt;br&gt;
身份识别、属性分析&lt;br&gt;
…&lt;/li&gt;
&lt;li&gt;智慧城市&lt;br</summary>
      
    
    
    
    <category term="深度学习" scheme="https://luotian.cyou/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MMLab" scheme="https://luotian.cyou/tags/MMLab/"/>
    
    <category term="深度学习" scheme="https://luotian.cyou/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MMclassification 与深度学习环境配置</title>
    <link href="https://luotian.cyou/post/MM-cls.html"/>
    <id>https://luotian.cyou/post/MM-cls.html</id>
    <published>2023-02-07T13:08:00.000Z</published>
    <updated>2025-07-09T18:12:17.290Z</updated>
    
    <content type="html"><![CDATA[<p>  由于本人之前没有接触过 python 和机器学习的相关知识，这次图像分类的配置过程可谓一路艰辛，本文当是一次避坑总结。</p><p><strong>配置环境概览:</strong></p><blockquote><p>平台: Windows 11<br>Python: 3.9.16<br>GPU: 本地 GPU<br>CUDA: 11.7<br>cuDNN: 8.5<br>Pytorch: 1.13.1<br>OpenCV: 4.6.0<br>MMCV: 1.7.0<br>MMCls: 0.25.0</p></blockquote><h1>一、环境安装</h1><p>  整体环境框架如下：<br><img src="/img/cls/3.png" alt=""></p><h2 id="1-CUDA-与-cuDNN-安装">1. CUDA 与 cuDNN 安装</h2><p>  网上有很多的教程，这里就不再赘述了，不过我以后有时间会补充上滴。这里推荐一个：<a href="https://blog.csdn.net/weixin_43848614/article/details/117221384" target="_blank" rel="noopener noreferrer">【CUDA】cuda 安装</a>。<br>  不过有一点要说明，在安装 CUDA 之前要先看一下自己的显卡最高支持的 CUDA 版本和适合于 Pytorch 的 CUDA 版本，版本安装错了后面会出现很多问题。<br>  比如我的 NVIDIA GPU 最高支持到 CUDA 12.0，Pytorch 官网目前最高支持到 CUDA 11.7，因此选择 CUDA 11.7 就 OK。</p><h2 id="2-ANACONDA-环境与-Pycharm-配置">2. ANACONDA 环境与 Pycharm 配置</h2><h3 id="2-1-ANACONDA-安装">2.1 ANACONDA 安装</h3><p>  ANACONDA（conda）不仅自带了许多 Python 的包，同时可以创建 Python 虚拟环境，与系统自身的环境相隔离，方便一大堆包的管理。这里参考 <a href="https://blog.csdn.net/in546/article/details/117400839" target="_blank" rel="noopener noreferrer">anaconda 安装超详细版</a>。</p><ul><li>下载：<br><a href="https://www.anaconda.com" target="_blank" rel="noopener noreferrer">官网</a><br><a href="https://mirrors.bfsu.edu.cn/anaconda/archive" target="_blank" rel="noopener noreferrer">镜像站</a>（速度快，推荐，如下图）<br><img src="/img/cls/1.png" alt=""><br>  版本选择合适的即可，我选择的是最新的一个版本 Anaconda3-2022.10-Windows-x86_64.exe ，自带 Python3.9。</li><li>安装：<br>  点击<strong> exe</strong> —— <strong>Next</strong> —— <strong>Next</strong> —— <strong>选择一个合适的安装路径</strong> — <strong>Next</strong> —— <strong>全选（添加 conda 到环境变量中），Install</strong> —— <strong>Next</strong> —— <strong>两个√去掉</strong> —— <strong>Finish</strong><br>  里面有个 “添加 conda 到环境变量中” 的选项一定要选上！</li><li>检验安装：<br>  在 windows 终端（cmd）输入 <em>python</em> ，回车，查看是否有 Python 环境，若显示 <em>Python 3.9.16</em> 就说明 OK。<br>  在 windows 终端（cmd）输入 <em>conda --version</em> ，回车，查看 conda 是否成功安装，若显示 <em>conda 22.9.0</em> 就说明 OK。</li><li>更换 conda 源（加快第三方库的安装速度）<br>  打开 Anaconda prompt，逐条输入：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></tbody></table></figure><p>  查看是否已更改下载源：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">conda config --show channels</span><br></pre></td></tr></tbody></table></figure><ul><li>创建虚拟环境：<br>  创建一个 Python 虚拟环境，这样方便后面对一大堆 py 包的管理。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 查看已有虚拟环境：</span><br><span class="line">conda env list</span><br><span class="line">conda info -e</span><br><span class="line"># 创建虚拟环境</span><br><span class="line">conda create -n env_name python=x.x</span><br><span class="line"># 激活虚拟环境</span><br><span class="line">activate env_name</span><br><span class="line"># 删除虚拟环境</span><br><span class="line">conda remove -n env_name --all</span><br><span class="line"># 切换回默认环境</span><br><span class="line">deactivate env_name</span><br><span class="line">activate base</span><br><span class="line">activate</span><br></pre></td></tr></tbody></table></figure><p>  比如我创建虚拟环境为：<em>conda create -n pytorch_env python=3.9</em> 。过程中会让你输入<em> y</em> 进行确认。<br>  在第一次创建虚拟环境的过程中可能会遇到 SSLErorr 的报错，意思是说需要安装 Open SSL ，网上的教程是到<a href="https://slproweb.com/products/Win32OpenSSL.html" target="_blank" rel="noopener noreferrer">Open SSL 官网</a>下载相应版本的软件，安装过程中勾选 “The Windows system directory”。但是我电脑因为系统保护等原因还是不行，这时发现 conda 的安装目录 <em>ANACODA\Library\bin\</em> 中有 openssl.exe 和 openssl.pdb 这两个文件，我把它们复制到 <em>C:\Windows\System32\</em> 中，意外的就好了。</p><h3 id="2-2-在-PyCharm-2022-中使用-conda-虚拟环境">2.2 在 PyCharm 2022 中使用 conda 虚拟环境</h3><p>  可选操作，实际中大部分过程 PyCharm 只被我当作了 python 文件的编辑器，运行全在终端上完成。这个虚拟环境因为我老早之前就用上了，第一次怎么添加的我记不清了，不过我这里推荐一个博客：<a href="https://blog.csdn.net/qq_39417912/article/details/105470790" target="_blank" rel="noopener noreferrer">在 pycharm 中使用 conda 虚拟环境（conda 虚拟环境是已经创建好的）</a>。</p><h2 id="3-第三方库安装">3. 第三方库安装</h2><p>  <strong>第三方库的安装必须要切换到对应的虚拟环境中去安装！后面对这些库的使用也要在该虚拟环境下进行！</strong><br>  比如我刚才创建好了一个虚拟环境 pytorch_env ，使用 conda 激活该虚拟环境之后，在该虚拟环境下面安装我们所用到的库，之后我想用这些库就切换到该环境即可。</p><h3 id="3-1-Pytorch-安装">3.1 Pytorch 安装</h3><ul><li>安装：<br>  进入<a href="https://pytorch.org" target="_blank" rel="noopener noreferrer">官网</a>，选择合适的版本：<br><img src="/img/cls/2.png" alt=""><br>  复制最后的那行代码到终端，回车等待安装完毕即可。</li><li>检验安装：<br>  还是该虚拟环境，逐条输入以下语句：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">python</span><br><span class="line">import torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></tbody></table></figure><p>  若返回 true，就说明目前你所有操作都是正确的。</p><h3 id="3-2-OpenMMLab-相关库安装">3.2 OpenMMLab 相关库安装</h3><ul><li>安装 mim</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">pip install -U openmim</span><br><span class="line">pip install openmim</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 mmcv-full</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mim install mmcv-full</span><br></pre></td></tr></tbody></table></figure><ul><li>安装 MMClassification<br>  按照官方的说法：</li></ul><ol><li>从源码安装（推荐）：希望基于 MMClassification 框架开发自己的图像分类任务，需要添加新的功能，比如新的模型或是数据集，或者使用我们提供的各种工具。</li><li>作为 Python 包安装：只是希望调用 MMClassification 的 API 接口，或者在自己的项目中导入 MMClassification 中的模块。<br>  我使用的是第一种源码安装：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git clone https://github.com/open-mmlab/mmclassification.git</span><br><span class="line">cd mmclassification</span><br><span class="line">pip install -v -e .</span><br><span class="line"># "-v" 表示输出更多安装相关的信息</span><br><span class="line"># "-e" 表示以可编辑形式安装，这样可以在不重新安装的情况下，让本地修改直接生效</span><br></pre></td></tr></tbody></table></figure><p>  这个时候你的终端就进入了 mmclassification 文件目录中，不出意外，你可以在 <em>C:\Users\User_name\</em> 中找到该文件夹。</p><ul><li>MMcls 测试<br>  下载下面的预训练模型：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">mim download mmcls --config resnet50_8xb32_in1k --dest .</span><br></pre></td></tr></tbody></table></figure><p><img src="/img/cls/4.png" alt=""><br>  运行测试脚本：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">python demo/image_demo.py demo/demo.JPEG resnet50_8xb32_in1k.py resnet50_8xb32_in1k_20210831-ea4938fc.pth --device cpu</span><br></pre></td></tr></tbody></table></figure><p>  如果出现下图所示的结果，就表明配置工作已经全部结束，接下来就可以进行模型的训练了：<br><img src="/img/cls/5.png" alt=""><br>  如果出现了问题，先看看上述步骤是否有所遗漏，再看看官方文档的教程。如果上述的步骤有任何错误也欢迎在评论区告诉我。</p><h1>二、模型训练</h1><h2 id="2-1准备数据集">2.1 准备数据集</h2><p>  我的数据集是在网上下载的 <a href="https://www.dropbox.com/s/snom6v4zfky0flx/flower_dataset.zip?dl=0" target="_blank" rel="noopener noreferrer">flower 数据集</a>，有 5 个文件夹，每个文件夹名对应一种花，分别为：daisy, dandelion, rose, sunflower, tulip, 每种花含有图片 500+ 张，而我们要将这个数据处理成 mmcls 能够处理的文件组织形式 —— ImageNet：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">flower_dataset</span><br><span class="line">|--- meta</span><br><span class="line">| |--- classmap.txt ——存放类与名称的对应关系</span><br><span class="line">| |--- train.txt ——训练集文件信息</span><br><span class="line">| |--- val.txt ——验证集文件信息</span><br><span class="line">| |--- test.txt ——测试集文件信息</span><br><span class="line">|--- train</span><br><span class="line">| |--- class1 ——某一种花的图片存放目录</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class2</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class3</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class4</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class5</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">|--- val</span><br><span class="line">| |--- class1</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class2</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class3</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class4</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class5</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">|--- test</span><br><span class="line">| |--- class1</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class2</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class3</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class4</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br><span class="line">| |--- class5</span><br><span class="line">| |    |--- NAME1.jpg</span><br><span class="line">| |    |--- ...</span><br></pre></td></tr></tbody></table></figure><p><em>Ps：本次训练我没有用到测试集</em><br>  网上也有些博主的文件组织形式和这个略不同，其实问题不大，后期只需要指定对应的文件路径就行。</p><ul><li>Step 1.<br>  我首先创建好了相应的文件夹，然后按照 train : val = 4 : 1 的比例对每一种花的图片进行数据划分，放入对应的 class 文件夹中。当然，我的图片种类比较少，所以就直接手动移动，网上也有博主分享了他们划分数据集的 Python 程序，可以借鉴使用一波。</li><li>Step 2.<br>  向 classmap.txt 文件写入以下内容：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class1 daisy 0</span><br><span class="line">class2 dandelion 1</span><br><span class="line">class3 rose 2</span><br><span class="line">class4 sunflower 3</span><br><span class="line">class5 tulip 4</span><br></pre></td></tr></tbody></table></figure><p>  向 train.txt 和 val.txt 文件中写入如下内容（test.txt 同理）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">class1/A119.jpg 0</span><br><span class="line">class1/A120.jpg 0</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>  当然，这个工作量太大了，我们不可能手写，这里我借用的是一位博主 <a href="https://blog.csdn.net/hzy459176895/article/details/123405552" target="_blank" rel="noopener noreferrer">何小义的 AI 进阶路</a> 的程序：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">生成train.txt  val.txt  test.txt</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 需要改为您自己的路径</span></span><br><span class="line">root_dir = <span class="string">"/xxx/data/cats_dogs"</span></span><br><span class="line"><span class="comment"># 在该路径下有train val test meta三个文件夹</span></span><br><span class="line">train_dir = os.path.join(root_dir, <span class="string">"train"</span>)</span><br><span class="line">val_dir = os.path.join(root_dir, <span class="string">"val"</span>)</span><br><span class="line">test_dir = os.path.join(root_dir, <span class="string">"test"</span>)</span><br><span class="line">meta_dir = os.path.join(root_dir, <span class="string">"meta"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_txt</span>(<span class="params">images_dir,map_dict</span>):</span><br><span class="line">    <span class="comment"># 读取所有文件名</span></span><br><span class="line">    imgs_dirs = glob.glob(images_dir+<span class="string">"/*/*"</span>)</span><br><span class="line"> </span><br><span class="line">    imgs_dirs = [ii.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>) <span class="keyword">for</span> ii <span class="keyword">in</span> imgs_dirs]</span><br><span class="line">    images_dir = images_dir.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>)</span><br><span class="line"> </span><br><span class="line">    typename = images_dir.split(<span class="string">"/"</span>)[-<span class="number">1</span>]</span><br><span class="line">    target_txt_path = os.path.join(meta_dir, typename+<span class="string">".txt"</span>)</span><br><span class="line">    f = <span class="built_in">open</span>(target_txt_path, <span class="string">"w"</span>)</span><br><span class="line">    <span class="comment"># 遍历所有图片名</span></span><br><span class="line">    <span class="keyword">for</span> img_dir <span class="keyword">in</span> imgs_dirs:</span><br><span class="line">        <span class="comment"># 获取第一级目录名称</span></span><br><span class="line">        filename = img_dir.split(<span class="string">"/"</span>)[-<span class="number">2</span>]</span><br><span class="line">        num = map_dict[filename]</span><br><span class="line">        <span class="comment"># 写入文件</span></span><br><span class="line">        relate_name = re.findall(typename+<span class="string">"/([\w / - .]*)"</span>,img_dir)</span><br><span class="line">        f.write(relate_name[<span class="number">0</span>]+<span class="string">" "</span>+num+<span class="string">"\n"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_map_dict</span>():</span><br><span class="line">    <span class="comment"># 读取所有类别映射关系</span></span><br><span class="line">    class_map_dict = {}</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(meta_dir, <span class="string">"classmap.txt"</span>),<span class="string">"r"</span>) <span class="keyword">as</span> F:</span><br><span class="line">        lines = F.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            line = line.split(<span class="string">"\n"</span>)[<span class="number">0</span>]</span><br><span class="line">            filename, cls, num = line.split(<span class="string">" "</span>)</span><br><span class="line">            class_map_dict[filename] = num</span><br><span class="line">    <span class="keyword">return</span> class_map_dict</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"> </span><br><span class="line">    class_map_dict = get_map_dict()</span><br><span class="line">    generate_txt(images_dir=train_dir, map_dict=class_map_dict)</span><br><span class="line">    generate_txt(images_dir=val_dir, map_dict=class_map_dict)</span><br><span class="line">    generate_txt(images_dir=test_dir, map_dict=class_map_dict)</span><br></pre></td></tr></tbody></table></figure><p>  然后数据集可以放在任何你想放置的地方，不过我为了调用方便，将数据集专门放在了 *mmclassification\data* 文件夹中（要自己新建一个）。</p><h2 id="2-1准备配置文件">2.1 准备配置文件</h2><h3 id="配置文件结构">配置文件结构</h3><p>  在 <em>configs\<em>base</em>\</em> 文件夹下有 4 个基本组件类型，分别是：</p><ol><li>模型 (model)</li><li>数据 (data)</li><li>训练策略 (schedule)</li><li>运行设置 (runtime)</li></ol><p>  在 <em>configs\</em> 中其他的文件夹则是各训练模型总的配置文件，比如 <em>configs\mobilenet_v2\mobilenet-v2_8xb32_in1k.py</em> 中可以看到该模型的配置属性：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">_base_ = [</span><br><span class="line">    <span class="string">'../_base_/models/mobilenet_v2_1x.py'</span>,               <span class="comment"># 模型</span></span><br><span class="line">    <span class="string">'../_base_/datasets/imagenet_bs32_pil_resize.py'</span>,    <span class="comment"># 数据</span></span><br><span class="line">    <span class="string">'../_base_/schedules/imagenet_bs256_epochstep.py'</span>,   <span class="comment"># 训练策略</span></span><br><span class="line">    <span class="string">'../_base_/default_runtime.py'</span>                       <span class="comment"># 默认运行设置</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>  你可以选择任何合适的模型，我这里使用的是 resnet18b32x8 模型，因为我对 python 不熟，所以就按照官方的模板进行配置。</p><h3 id="注册自己的数据集">注册自己的数据集</h3><p>  新建 <em>mmcls\datasets\flower_dataset.py</em> ，建立自己的数据集定义脚本。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> .builder <span class="keyword">import</span> DATASETS</span><br><span class="line"><span class="keyword">from</span> .base_dataset <span class="keyword">import</span> BaseDataset</span><br><span class="line"></span><br><span class="line"><span class="meta">@DATASETS.register_module()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FlowerDatasets</span>(<span class="title class_ inherited__">BaseDataset</span>): <span class="comment"># 这里要记好这个类的名称，之后会用到</span></span><br><span class="line">    CLASSES = [<span class="string">"daisy"</span>, <span class="string">"dandelion"</span>, <span class="string">"rose"</span>, <span class="string">"sunflower"</span>, <span class="string">"tulip"</span>] <span class="comment"># 修改为自己的数据标签</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_annotations</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(<span class="variable language_">self</span>.ann_file, <span class="built_in">str</span>)</span><br><span class="line">        data_infos = []</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="variable language_">self</span>.ann_file) <span class="keyword">as</span> f:</span><br><span class="line">            samples = [x.strip().split(<span class="string">' '</span>) <span class="keyword">for</span> x <span class="keyword">in</span> f.readlines()]</span><br><span class="line">            <span class="keyword">for</span> filename, gt_label <span class="keyword">in</span> samples:</span><br><span class="line">                info = {<span class="string">'img_prefix'</span>: <span class="variable language_">self</span>.data_prefix,</span><br><span class="line">                        <span class="string">'img_info'</span>: {<span class="string">'filename'</span>: filename},</span><br><span class="line">                        <span class="string">'gt_label'</span>: np.array(gt_label, dtype=np.int64)}</span><br><span class="line">                data_infos.append(info)</span><br><span class="line">            <span class="keyword">return</span> data_infos</span><br></pre></td></tr></tbody></table></figure><p>  在 <em>mmcls\datasets\<strong>init</strong>.py</em> 中添加自己定义的数据集，进行注册：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">from</span> .flower_dataset <span class="keyword">import</span> FlowerDatasets <span class="comment"># import 后面是类的名称</span></span><br><span class="line">__all__ = [</span><br><span class="line">    <span class="string">'BaseDataset'</span>, <span class="string">'ImageNet'</span>, <span class="string">'CIFAR10'</span>, <span class="string">'CIFAR100'</span>, <span class="string">'MNIST'</span>, <span class="string">'FashionMNIST'</span>,</span><br><span class="line">    <span class="string">'VOC'</span>, <span class="string">'MultiLabelDataset'</span>, <span class="string">'build_dataloader'</span>, <span class="string">'build_dataset'</span>,</span><br><span class="line">    <span class="string">'DistributedSampler'</span>, <span class="string">'ConcatDataset'</span>, <span class="string">'RepeatDataset'</span>,</span><br><span class="line">    <span class="string">'ClassBalancedDataset'</span>, <span class="string">'DATASETS'</span>, <span class="string">'PIPELINES'</span>, <span class="string">'ImageNet21k'</span>, <span class="string">'SAMPLERS'</span>,</span><br><span class="line">    <span class="string">'build_sampler'</span>, <span class="string">'RepeatAugSampler'</span>, <span class="string">'KFoldDataset'</span>, <span class="string">'CUB'</span>,</span><br><span class="line">    <span class="string">'CustomDataset'</span>, <span class="string">'StanfordCars'</span>, <span class="string">'FlowerDatasets'</span> <span class="comment"># 将自己类的名称添加到后面</span></span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="设置数据配置文件">设置数据配置文件</h3><p>  新建 <em>config\<em>base</em>\datasets\flower_dataset.py</em>，导入自己的数据，并进行相关操作。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># dataset settings</span></span><br><span class="line">dataset_type = <span class="string">'FlowerDatasets'</span>  <span class="comment"># 数据集名称，换成自己刚刚注册的那个名字</span></span><br><span class="line">img_norm_cfg = <span class="built_in">dict</span>(  <span class="comment">#图像归一化配置，用来归一化输入的图像</span></span><br><span class="line">    mean=[<span class="number">123.675</span>, <span class="number">116.28</span>, <span class="number">103.53</span>], </span><br><span class="line">std=[<span class="number">58.395</span>, <span class="number">57.12</span>, <span class="number">57.375</span>], </span><br><span class="line">to_rgb=<span class="literal">True</span>)  <span class="comment"># 是否反转通道，使用 cv2, mmcv 读取图片默认为 BGR 通道顺序，这里 Normalize 均值方差数组的数值是以 RGB 通道顺序， 因此需要反转通道顺序</span></span><br><span class="line"><span class="comment"># 训练数据流水线</span></span><br><span class="line">train_pipeline = [</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'LoadImageFromFile'</span>),  <span class="comment"># 读取图片</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'RandomResizedCrop'</span>, size=<span class="number">224</span>),  <span class="comment"># 随机缩放裁剪</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'RandomFlip'</span>, flip_prob=<span class="number">0.5</span>, direction=<span class="string">'horizontal'</span>),  <span class="comment"># 随机翻转</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'Normalize'</span>, **img_norm_cfg),  <span class="comment"># 归一化</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'ImageToTensor'</span>, keys=[<span class="string">'img'</span>]),  <span class="comment"># image 转为 torch.Tensor</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'ToTensor'</span>, keys=[<span class="string">'gt_label'</span>]),  <span class="comment"># gt_label 转为 torch.Tensor</span></span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>, <span class="string">'gt_label'</span>])  <span class="comment"># 图像和标签的集合</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 测试数据流水线</span></span><br><span class="line">test_pipeline = [</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'LoadImageFromFile'</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'Resize'</span>, size=(<span class="number">256</span>, -<span class="number">1</span>)),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'CenterCrop'</span>, crop_size=<span class="number">224</span>),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'Normalize'</span>, **img_norm_cfg),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'ImageToTensor'</span>, keys=[<span class="string">'img'</span>]),</span><br><span class="line">    <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'Collect'</span>, keys=[<span class="string">'img'</span>])  <span class="comment"># test 时不传递 gt_label</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">data_root = <span class="string">'.../mmclassification/data/flower_dataset'</span>  <span class="comment"># 你的数据集根目录</span></span><br><span class="line">data = <span class="built_in">dict</span>(</span><br><span class="line">    samples_per_gpu=<span class="number">32</span>,  <span class="comment"># dataloader.batch_size == self.samples_per_gpu  # 每批次样本数量</span></span><br><span class="line">    workers_per_gpu=<span class="number">2</span>,  <span class="comment"># dataloader.num_workers == self.workers_per_gpu  # 1的话表示只有一个进程加载数据</span></span><br><span class="line">    train=<span class="built_in">dict</span>(  <span class="comment"># 训练数据信息</span></span><br><span class="line">        <span class="built_in">type</span>=dataset_type,  <span class="comment"># 数据集名称</span></span><br><span class="line">        data_prefix=data_root + <span class="string">'/train'</span>,  <span class="comment"># 对应到指定的文件夹和文件中</span></span><br><span class="line">        ann_file=data_root + <span class="string">'/meta/train.txt'</span>,  <span class="comment"># 数据集目录，当不存在 ann_file 时，类别信息从文件夹自动获取</span></span><br><span class="line">        pipeline=train_pipeline),   <span class="comment"># 数据集需要经过的数据流水线</span></span><br><span class="line">    val=<span class="built_in">dict</span>(   <span class="comment"># 验证数据集信息</span></span><br><span class="line">        <span class="built_in">type</span>=dataset_type,</span><br><span class="line">        data_prefix=data_root + <span class="string">'/val'</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">'/meta/val.txt'</span>,</span><br><span class="line">        pipeline=test_pipeline),</span><br><span class="line">    test=<span class="built_in">dict</span>(   <span class="comment"># 测试数据集信息</span></span><br><span class="line">        <span class="comment"># replace `data/val` with `data/test` for standard test</span></span><br><span class="line">        <span class="built_in">type</span>=dataset_type,</span><br><span class="line">        data_prefix=data_root + <span class="string">'/val'</span>,</span><br><span class="line">        ann_file=data_root + <span class="string">'/meta/val.txt'</span>,</span><br><span class="line">        pipeline=test_pipeline</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line">evaluation = <span class="built_in">dict</span>(  <span class="comment"># evaluation hook 的配置</span></span><br><span class="line">interval=<span class="number">1</span>,  <span class="comment"># 验证期间的间隔，单位为 epoch 或者 iter， 取决于 runner 类型</span></span><br><span class="line">metric=<span class="string">'accuracy'</span>)  <span class="comment"># 验证期间使用的指标</span></span><br></pre></td></tr></tbody></table></figure><h3 id="设置模型配置文件">设置模型配置文件</h3><p>  访问 <a href="https://github.com/open-mmlab/mmclassification/blob/dev/docs/en/model_zoo.md" target="_blank" rel="noopener noreferrer">Model Zoo</a>，找到本次训练使用的模型：<br><img src="/img/cls/7.png" alt=""><br>  点击 model，将模型下载到本地。为了方便管理，我统一放在了 <em>mmclassification\checkpoints\</em> 中，（自己新建一个文件夹）。<br>  新建 <em>config\<em>base</em>\model\flowers_resnet18.py</em>，对模型进行初始化。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># model settings</span></span><br><span class="line">model = <span class="built_in">dict</span>(</span><br><span class="line">    <span class="built_in">type</span>=<span class="string">'ImageClassifier'</span>, <span class="comment"># 分类器类型</span></span><br><span class="line">    backbone=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">'ResNet'</span>, <span class="comment"># 主干网络类型</span></span><br><span class="line">        depth=<span class="number">18</span>,  <span class="comment"># 主干网络深度，这里是 18</span></span><br><span class="line">        num_stages=<span class="number">4</span>,  <span class="comment"># 主干网络状态(stages)的数目，这些状态产生的特征图作为后续的 head 的输入</span></span><br><span class="line">        out_indices=(<span class="number">3</span>,),  <span class="comment"># 输出的特征图输出索引。越远离输入图像，索引越大</span></span><br><span class="line">        style=<span class="string">'pytorch'</span>,</span><br><span class="line">        init_cfg=<span class="built_in">dict</span>(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">'Pretrained'</span>,</span><br><span class="line">            checkpoint=<span class="string">'.../mmclassification/checkpoints/resnet18_batch256_imagenet_20200708-34ab8f90.pth'</span>,  <span class="comment"># 读取预训练模型，这里是它的存放地址，换成自己的</span></span><br><span class="line">            prefix=<span class="string">'backbone'</span>,</span><br><span class="line">            ),</span><br><span class="line">        frozen_stages=<span class="number">2</span>,  <span class="comment"># 加入预训练模型时候，冻结前两层（实验证明，冻结部分权重，效果更好）</span></span><br><span class="line">    ),</span><br><span class="line">    neck=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'GlobalAveragePooling'</span>),  <span class="comment"># 颈网络类型，neck：平均池化</span></span><br><span class="line">    head=<span class="built_in">dict</span>(</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">'LinearClsHead'</span>,  <span class="comment"># 线性分类头</span></span><br><span class="line">        num_classes=<span class="number">5</span>,  <span class="comment"># 输出类别数，与数据集的类别数一致，要自己修改</span></span><br><span class="line">        in_channels=<span class="number">512</span>,  <span class="comment"># 输入通道数，与 neck 的输出通道一致，一般默认</span></span><br><span class="line">        loss=<span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'CrossEntropyLoss'</span>, loss_weight=<span class="number">1.0</span>),  <span class="comment"># 损失函数配置信息，分类，交叉熵</span></span><br><span class="line">        topk=(<span class="number">1</span>, <span class="number">5</span>),  <span class="comment"># 评估指标，Top-k 准确率， 这里为 top1 与 top5 准确率</span></span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h3 id="设置训练策略文件">设置训练策略文件</h3><p>  可以新建也可以不新建，我直接用的 <em>config\<em>base</em>\schedules\imagenet_bs256.py</em> 。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 用于构建优化器的配置文件。支持 PyTorch 中的所有优化器，同时它们的参数与 PyTorch 里的优化器参数一致</span></span><br><span class="line">optimizer = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'SGD'</span>,         <span class="comment"># 优化器类型</span></span><br><span class="line">                lr=<span class="number">0.1</span>,              <span class="comment"># 优化器的学习率，参数的使用细节请参照对应的 PyTorch 文档</span></span><br><span class="line">                momentum=<span class="number">0.9</span>,        <span class="comment"># 动量(Momentum)</span></span><br><span class="line">                weight_decay=<span class="number">0.0001</span>) <span class="comment"># 权重衰减系数(weight decay)。</span></span><br><span class="line"> <span class="comment"># optimizer hook 的配置文件</span></span><br><span class="line">optimizer_config = <span class="built_in">dict</span>(grad_clip=<span class="literal">None</span>)  <span class="comment"># 大多数方法不使用梯度限制(grad_clip)。</span></span><br><span class="line"><span class="comment"># 学习率调整配置，用于注册 LrUpdater hook。</span></span><br><span class="line">lr_config = <span class="built_in">dict</span>(policy=<span class="string">'step'</span>,          <span class="comment"># 调度流程(scheduler)的策略，也支持 CosineAnnealing, Cyclic 等</span></span><br><span class="line">                 step=[<span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>])      <span class="comment"># 在 epoch 为 30, 60, 90 时，lr 进行衰减</span></span><br><span class="line">runner = <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'EpochBasedRunner'</span>,   <span class="comment"># 将使用的 runner 的类别，如 IterBasedRunner 或 EpochBasedRunner</span></span><br><span class="line">            max_epochs=<span class="number">100</span>)              <span class="comment"># runner 总回合数， 对于 IterBasedRunner 使用 `max_iters`</span></span><br></pre></td></tr></tbody></table></figure><h3 id="运行文件设置">运行文件设置</h3><p>  在 <em>config\<em>base</em>\default_runtime.py</em> 中，设置多少批次打印日志，多少次迭代保存一次模型等等。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Checkpoint hook 的配置文件</span></span><br><span class="line">checkpoint_config = <span class="built_in">dict</span>(interval=<span class="number">1</span>)   <span class="comment"># 保存的间隔是 1，单位会根据 runner 不同变动，可以为 epoch 或者 iter。</span></span><br><span class="line"><span class="comment"># 日志配置信息。</span></span><br><span class="line">log_config = <span class="built_in">dict</span>(</span><br><span class="line">    interval=<span class="number">25</span>,                      <span class="comment"># 打印日志的间隔，单位 iters</span></span><br><span class="line">    hooks=[</span><br><span class="line">        <span class="built_in">dict</span>(<span class="built_in">type</span>=<span class="string">'TextLoggerHook'</span>),          <span class="comment"># 用于记录训练过程的文本记录器(logger)。</span></span><br><span class="line">        <span class="comment"># dict(type='TensorboardLoggerHook')  # 同样支持 Tensorboard 日志</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">dist_params = <span class="built_in">dict</span>(backend=<span class="string">'nccl'</span>)   <span class="comment"># 用于设置分布式训练的参数，端口也同样可被设置</span></span><br><span class="line">log_level = <span class="string">'INFO'</span>             <span class="comment"># 日志的输出级别</span></span><br><span class="line">load_from = <span class="literal">None</span></span><br><span class="line">resume_from = <span class="literal">None</span>             <span class="comment"># 从给定路径里恢复检查点(checkpoints)，训练模式将从检查点保存的轮次开始恢复训练。</span></span><br><span class="line">workflow = [(<span class="string">'train'</span>, <span class="number">1</span>)]      <span class="comment"># runner 的工作流程，[('train', 1)] 表示只有一个工作流且工作流仅执行一次。</span></span><br><span class="line">work_dir = <span class="string">'work_dir'</span>          <span class="comment"># 用于保存当前实验的模型检查点和日志的目录文件地址。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="设置模型主脚本">设置模型主脚本</h3><p>  新建 <em>configs\resnet\flower_resnet18_b32x8_imagenet.py</em>，将上述四个配置文件按顺序加入进来。</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">_base_ = [</span><br><span class="line">    <span class="string">'../_base_/models/flowers_resnet18.py'</span>,  <span class="comment"># model config</span></span><br><span class="line">    <span class="string">'../_base_/datasets/flower_dataset.py'</span>,  <span class="comment"># data config</span></span><br><span class="line">    <span class="string">'../_base_/schedules/imagenet_bs256.py'</span>,  <span class="comment"># schedules config</span></span><br><span class="line">    <span class="string">'../_base_/default_runtime.py'</span>  <span class="comment"># runtime config</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><h2 id="2-2-训练">2.2 训练</h2><p>  目录 <em>…\mmclassification\tools\</em> 中存放的是 mmcls 相关工具脚本，打开 <em>tools\train.py</em> ，这个就是启动训练的 Python 脚本。修改这两行：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'config'</span>, default=<span class="string">"configs/resnet/flower_resnet18_b32x8_imagenet.py"</span>, <span class="built_in">help</span>=<span class="string">'train config file path'</span>)  <span class="comment"># 添加模型主脚本的相对路径</span></span><br><span class="line">parser.add_argument(<span class="string">'--work-dir'</span>, default=<span class="string">"train_result/flowers"</span>, <span class="built_in">help</span>=<span class="string">'the dir to save logs and models'</span>)  <span class="comment"># 添加模型运行结果的保存路径，没有的话会自动创建</span></span><br></pre></td></tr></tbody></table></figure><p>  在终端中输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">python tools/train.py configs/resnet/flower_resnet18_b32x8_imagenet.py</span><br></pre></td></tr></tbody></table></figure><p>  就开始了正式训练。结束之后，可以在 <em>train_result\flowers\</em> 中找到训练的结果。其中 latest.pth 就是最终训练好的模型文件。</p><h2 id="2-3-验证">2.3 验证</h2><p>  测试的脚本在 <em>tools\test.py</em> ，这次我们直接在终端中输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">python tools/test.py configs/resnet/flower_resnet18_b32x8_imagenet.py train_result/flowers/latest.pth --out=val_res.json --metrics=accuracy</span><br></pre></td></tr></tbody></table></figure><p>  测试完成终端便会打印 top1 与 top5 的准确率，同时在 <em>train_result\flowers\val_res.json</em> 中还可以看到更加详细的测试情况。</p><h1>总结</h1><p>  配置过程太艰辛了，尤其是像我这种没有任何基础的小白，有任何一个步骤出现了问题后面就都会出错。不过万事开头难，还是要脚踏实地一步一步的来。</p><h4 id="附录">附录</h4><ul><li><a href="https://mmclassification.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener noreferrer">MMClassification 官方中文文档</a></li><li><a href="https://github.com/open-mmlab/mmclassification/blob/dev/docs/en/model_zoo.md" target="_blank" rel="noopener noreferrer">MMCls Model Zoo</a></li><li><a href="https://blog.csdn.net/Stone_hello/article/details/117026516" target="_blank" rel="noopener noreferrer">mmclassification 图像分类 —— 模型训练</a></li><li><a href="https://blog.csdn.net/hzy459176895/article/details/123405552" target="_blank" rel="noopener noreferrer">记录一次 mmclassification 自定义数据训练和推理</a></li><li><a href="https://blog.csdn.net/weixin_43216130/article/details/115312600" target="_blank" rel="noopener noreferrer">mmclassification 自定义数据集并训练</a></li><li><a href="https://blog.csdn.net/weixin_34910922/article/details/107801656" target="_blank" rel="noopener noreferrer">mmclassification - 安装使用</a></li><li><a href="https://blog.csdn.net/suiyingy/article/details/125452839" target="_blank" rel="noopener noreferrer">mmclassification 安装与调试</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  由于本人之前没有接触过 python 和机器学习的相关知识，这次图像分类的配置过程可谓一路艰辛，本文当是一次避坑总结。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置环境概览:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;平台: Windows 11&lt;br&gt;
Pyth</summary>
      
    
    
    
    <category term="深度学习" scheme="https://luotian.cyou/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="MMLab" scheme="https://luotian.cyou/tags/MMLab/"/>
    
    <category term="环境配置" scheme="https://luotian.cyou/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
